<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++基础</title>
    <url>/2022/10/01/c-ji-chu/</url>
    <content><![CDATA[<ul>
<li>
<h3 id="c基础"><a class="anchor" href="#c基础">#</a> C++ 基础</h3>
<h4 id="基础语法"><a class="anchor" href="#基础语法">#</a> 基础语法</h4>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">// 输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  <span class="comment">// 命名空间</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入输出</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin, str); <span class="comment">// 获取一整行的输入（cin无法将空格连接的输入全部接收）</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> PI = <span class="number">3.14</span>; <span class="comment">// const 类型-定义常量（类似宏定义）</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="number">-1</span>;      <span class="comment">// bool 类型-非0即是：true 或 1</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串长度：str.length()</span></span><br><span class="line"><span class="type">int</span> length = s.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串切片：str.substr(起始位置,切片数量),省略数量则默认至结尾</span></span><br><span class="line">string sub_str = s.<span class="built_in">substr</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">string &amp;s_name = s; </span><br><span class="line"><span class="comment">// 引用：给s取了一个别名,修改s_name就是修改s</span></span><br><span class="line"><span class="comment">// 定义函数时的参数中使用：int func(int &amp;局部变量)</span></span><br><span class="line"><span class="comment">// 相当于给传入参数取了别名,这样就可以直接在函数中修改全局变量）</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">bool</span> sex;</span><br><span class="line">&#125;; <span class="comment">// struct 别名&#123;&#125;, 别名==该结构体类型,可直接用别名来创建新的结构体</span></span><br><span class="line">Person JZJ = &#123;<span class="number">39</span>, <span class="number">21</span>, <span class="string">&quot;jzj&quot;</span>, <span class="string">&quot;1&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="stl容器"><a class="anchor" href="#stl容器">#</a> STL 容器</h4>
<ul>
<li><strong>容器公共方法：容器.size ()</strong></li>
</ul>
<h5 id="vector"><a class="anchor" href="#vector">#</a> vector</h5>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;vector&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr;         <span class="comment">// 数组未初始化</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">// 数组初始化分配了10个空间，未给定元素(默认为0)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr2</span><span class="params">(<span class="number">10</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 数组初始化分配了10个空间，每个元素都为2</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">arr.<span class="built_in">resize</span>(<span class="number">10</span>); 	<span class="comment">//分配数组的空间</span></span><br><span class="line">arr.<span class="built_in">size</span>()		<span class="comment">// 容器长度</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;分配数组大小后的长度为：&quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">arr.<span class="built_in">push_back</span>(<span class="number">10</span>); <span class="comment">// 在数组末尾插入一个元素</span></span><br><span class="line">arr.<span class="built_in">pop_back</span>();	   <span class="comment">// 删除数组末尾的一个元素</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>
<p>迭代器</p>
<ul>
<li>
<p>set.begin () 是第一个元素的【地址】</p>
</li>
<li>
<p>set.end () 是末尾元素的下一个元素的【地址】</p>
</li>
<li>
<p>p 是一个指针，自动遍历数组，直至数组【末尾元素的下一个元素的地址】</p>
</li>
<li>
<p>arr.begin () 和 arr.end () 都是一个【地址】，而不是元素本身</p>
</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = arr2.<span class="built_in">begin</span>(); p != arr2.<span class="built_in">end</span>(); p++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<h5 id="set"><a class="anchor" href="#set">#</a> set</h5>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;set&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; set1;</span><br><span class="line"><span class="comment">// 集合不需要初始化</span></span><br><span class="line"><span class="comment">// 集合中的元素不重复，且集合中的元素会(从小到大)自动排序</span></span><br></pre></td></tr></table></figure></p>
<p>插入</p>
<p>set.insert(data)</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set1.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">set1.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">set1.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 集合中的元素不重复，且集合中的元素会(从小到大)自动排序</span></span><br></pre></td></tr></table></figure></p>
<p>删除</p>
<p>set.erase(data)</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set1.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>查找</p>
<ul>
<li>
<p>find 查找会从集合的 set.begin () 位置一致查到 set.end () 位置，返回值是：[地址]</p>
</li>
<li>
<p>set.end () 是容器末尾元素的下一个地址，而不是末尾元素地址</p>
</li>
<li>
<p>查找集合中不存在的元素，则会返回 set.end () 的地址</p>
</li>
<li>
<p>查找整个集合直到末尾元素的下一个地址 set.end () 也没找到则退出</p>
</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; (set1.<span class="built_in">find</span>(<span class="number">1</span>) != set1.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (set1.<span class="built_in">find</span>(<span class="number">3</span>) != set1.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>遍历</p>
<ul>
<li>
<p>迭代器</p>
</li>
<li>
<p>set.begin () 是第一个元素的【地址】</p>
</li>
<li>
<p>set.end () 是末尾元素的下一个元素的【地址】</p>
</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = set1.<span class="built_in">begin</span>(); p != set1.<span class="built_in">end</span>(); p++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="map"><a class="anchor" href="#map">#</a> map</h5>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;map&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>
<p>创建 map 键值对</p>
<ul>
<li>
<p>map &lt;键的类型，值的类型&gt; 变量；</p>
</li>
<li>
<p>map 中的键值对会按照依次根据【键】和【值】的 ASCII 码进行排序</p>
</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; map1;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>添加键值对</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map1[<span class="string">&quot;学号&quot;</span>] = <span class="number">39</span>;</span><br><span class="line">map1[<span class="string">&quot;年龄&quot;</span>] = <span class="number">21</span>;</span><br><span class="line">map1[<span class="string">&quot;性别&quot;</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>访问</p>
<ul>
<li>
<p>访问的键值对存在：则返回值</p>
</li>
<li>
<p>访问的键值对不存在：则立即创建该键值对，且值为 0</p>
</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;学号：&quot;</span> &lt;&lt; map1[<span class="string">&quot;学号&quot;</span>] &lt;&lt; endl;<span class="comment">// 存在，打印值：39</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; map1[<span class="string">&quot;姓名&quot;</span>] &lt;&lt; endl;<span class="comment">// 不存在，创建并打印值：0</span></span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>遍历</p>
<ul>
<li>
<p>迭代器遍历：从第一个键值对遍历到最后一个键值对的下一个地址后结束</p>
</li>
<li>
<p>map 键值对相当于一个包含了【键】和【值】两个成员的结构体</p>
</li>
<li>
<p>键值对的第一个元素是键：p-&gt;first</p>
</li>
<li>
<p>键值对的第二个元素是值：p-&gt;second</p>
</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = map1.<span class="built_in">begin</span>(); p != map1.<span class="built_in">end</span>(); p++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; p-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; p-&gt;second &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<h5 id="stack"><a class="anchor" href="#stack">#</a> stack</h5>
<ul>
<li><strong>栈：先进后出，只能访问栈顶元素</strong></li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stack1;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>
<p>压栈</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack1.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stack1.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">stack1.<span class="built_in">push</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>访问栈顶元素</p>
<p>stack.top()</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;栈顶元素为：&quot;</span> &lt;&lt; stack1.<span class="built_in">top</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>出栈</p>
<p>stack.pop()</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack1.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;栈顶元素为：&quot;</span> &lt;&lt; stack1.<span class="built_in">top</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<h5 id="queue"><a class="anchor" href="#queue">#</a> queue</h5>
<p><strong>队列：先进先出，只能访问队首和队尾元素</strong></p>
<p><strong>队尾入队，队首出队</strong></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;queue&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; queue1;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>
<p>入队</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue1.<span class="built_in">push</span>(i);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>出队</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue1.<span class="built_in">pop</span>()</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>访问</p>
<ul>
<li>
<p>队首元素：queue1.front ()</p>
</li>
<li>
<p>队尾元素：queue1.back ()</p>
</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;队首元素为：&quot;</span> &lt;&lt; queue1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队尾元素为：&quot;</span> &lt;&lt; queue1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<h5 id="unordered_map-unordered_set"><a class="anchor" href="#unordered_map-unordered_set">#</a> unordered_map &amp; unordered_set</h5>
<ul>
<li>直接创建的 map 和 set 都会自动进行排序</li>
<li>使用排序的容器，会增加时间复杂度</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;unordered_map&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;unordered_set&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map &lt;string, <span class="type">int</span>&gt; map1;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; set1;</span><br></pre></td></tr></table></figure></p>
<h5 id="bitset"><a class="anchor" href="#bitset">#</a> bitset</h5>
<ul>
<li>位运算</li>
<li>bitset 类似于一个字符数组，将二进制的每一位字符【由低位到高位保存】</li>
<li>所以该字符数组 [0] 是最低位，正常读二进制时：是由高位到低位的排列 - arr [size]:arr [0]</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;bitset&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bitset&lt;5&gt; a;    <span class="comment">// 定义了五位二进制的数组,初始化为0（给定十进制数）</span></span><br><span class="line"><span class="function">bitset&lt;5&gt; <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>; <span class="comment">// 定义了五位二进制的数组,初始化为20（给定十进制数）</span></span><br><span class="line"><span class="function">bitset&lt;5&gt; <span class="title">c</span><span class="params">(<span class="string">&quot;1001&quot;</span>)</span></span>; <span class="comment">// 定义了五位二进制的数组,给定了二进制位的字符（不够0补）</span></span><br><span class="line">string s = <span class="string">&quot;11010101&quot;</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">5</span>&gt; (s,<span class="number">6</span>,<span class="number">5</span>);  <span class="comment">// 读取二进制字符串的第六位开始后的五位二进制位</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>
<p>处理</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">b.<span class="built_in">any</span>()   <span class="comment">// 是否存在1</span></span><br><span class="line">b.<span class="built_in">none</span>()  <span class="comment">// 是否全为0</span></span><br><span class="line">b.<span class="built_in">count</span>() <span class="comment">// 1的个数</span></span><br><span class="line">b.<span class="built_in">size</span>()  <span class="comment">// 元素个数</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">b.<span class="built_in">test</span>(<span class="number">0</span>);  <span class="comment">// 判断二进制第0位（最低位）是否为1</span></span><br><span class="line">b.<span class="built_in">set</span>(<span class="number">0</span>);   <span class="comment">// 将二进制第0位（最低位）设置为1</span></span><br><span class="line">b.<span class="built_in">reset</span>(); <span class="comment">// 所有位归零</span></span><br><span class="line">b.<span class="built_in">reset</span>(<span class="number">0</span>); <span class="comment">// 第0位（最低位）归零</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">b.<span class="built_in">flip</span>();   <span class="comment">// 所有位取反</span></span><br><span class="line">b.<span class="built_in">flip</span>(<span class="number">0</span>);  <span class="comment">// 第0位（最低位）取反</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> num = b.<span class="built_in">to_ullong</span>(); </span><br><span class="line"><span class="comment">// 将数组中的二进制数整体转换为 unsigned long 类型 (二进制——&gt;十进制)</span></span><br></pre></td></tr></table></figure></p>
<h5 id="sort"><a class="anchor" href="#sort">#</a> sort</h5>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;vector&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;algorithm&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>
<p>默认从小到大排序</p>
</li>
<li>
<p>选择排序的起始位置至结束位置的前一位 [左闭右开)</p>
</li>
<li>
<p>end () 是数组末尾元素的下一位地址</p>
<ul>
<li>默认排序</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></p>
<ul>
<li>根据规则排序</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从大到小排序 ：&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从小到大排序 ：&lt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),cmp1);</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
</li>
</ul>
<h5 id="ctype"><a class="anchor" href="#ctype">#</a> ctype</h5>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;cctype&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>判断函数</li>
</ul>
<p>返回值全为 bool 值 0/1</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否为字母、数字</span></span><br><span class="line"><span class="built_in">isalpha</span>(alpha)</span><br><span class="line"><span class="built_in">isalnum</span>(alpha)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空白字符：&quot; &quot;、\n、\r、\t 等空白字符</span></span><br><span class="line"><span class="built_in">isspace</span>(alpha)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断大小写</span></span><br><span class="line"><span class="built_in">isupper</span>(alpha)</span><br><span class="line"><span class="built_in">islower</span>(alpha)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>转换函数</li>
</ul>
<p>tolower (char) 和 toupper (char) 返回的是转换后的【ASCII 码】</p>
<p>需要将【ASCII】码以【char】字符类型打印才能是字母</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; alpha &lt;&lt; <span class="string">&quot; 转换为小写字母：&quot;</span> &lt;&lt; <span class="built_in">tolower</span>(alpha) &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="built_in">char</span>(alpha) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; alpha &lt;&lt; <span class="string">&quot; 转换为大写字母：&quot;</span> &lt;&lt; <span class="built_in">toupper</span>(alpha) &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="built_in">char</span>(alpha) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<h5 id="auto"><a class="anchor" href="#auto">#</a> auto</h5>
<ul>
<li>
<p>auto 根据初始化的值自动匹配变量的数据类型</p>
</li>
<li>
<p>使用 auto 声明变量时必须做初始化</p>
</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> name = <span class="string">&quot;姜子俊&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> high = <span class="number">173.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">0</span>;  <span class="comment">// 初始化auto匹配为int类型</span></span><br><span class="line">cin &gt;&gt; a;	 <span class="comment">// a为int类型，输入int类型给变量a</span></span><br></pre></td></tr></table></figure></p>
<h5 id="string"><a class="anchor" href="#string">#</a> string</h5>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure></p>
<p>将其他格式转换为字符串格式</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="built_in">to_string</span>(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用printf打印转换过来的字符串需要使用str.c_str()方法</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure></p>
<p>将字符串格式转换为其他格式</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="built_in">stoi</span>(<span class="string">&quot;110&quot;</span>);</span><br><span class="line"><span class="type">float</span> b = <span class="built_in">stof</span>(<span class="string">&quot;11.2&quot;</span>);</span><br><span class="line"><span class="type">double</span> c = <span class="built_in">stod</span>(<span class="string">&quot;3.1415926&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> d = <span class="built_in">stoll</span>(<span class="string">&quot;3.1415926&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> e = <span class="built_in">stoul</span>(<span class="string">&quot;3.1415926&quot;</span>);</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
]]></content>
      <categories>
        <category>高级编程语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础一</title>
    <url>/2022/08/25/c-yu-yan-ji-chu-yi/</url>
    <content><![CDATA[<h1 id="c语言基础一"><a class="anchor" href="#c语言基础一">#</a> C 语言基础一</h1>
<h4 id="第一个c语言程序helloworld"><a class="anchor" href="#第一个c语言程序helloworld">#</a> 第一个 C 语言程序：Hello，World</h4>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 头文件</span><br><span class="line">返回值类型 函数名(输入参数值)&#123;</span><br><span class="line">    相关操作</span><br><span class="line">    <span class="keyword">return</span> 函数返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>记得先导入 include——&gt; 头文件<strong> stdio.h</strong></li>
<li>头文件中声明了 printf 函数（定义在更深层）</li>
<li>每个程序有且仅有一个主函数：<strong>main 函数</strong></li>
<li>函数名前面是函数的<strong>返回值类型</strong>，与<strong> return</strong> 中的<strong>函数返回值</strong>的类型相对应</li>
<li>C 语言不同于脚本语言的 python：每行代码末尾都要加<strong>分号；<strong> 并且输出</strong>默认不换行</strong>需要自行加入 **&quot;\n&quot; 转义符 **</li>
</ol>
<h4 id="两数之和函数"><a class="anchor" href="#两数之和函数">#</a> 两数之和函数</h4>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    result = add(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>
<p>先定义 add 函数，在调用 add 函数</p>
</li>
<li>
<p>add 函数被主函数 main 调用，而<strong> main 函数</strong>会被<strong>自动调用</strong></p>
</li>
<li>
<p>C 语言标准规定：主函数有返回值切必须为 int 类型</p>
<ul>
<li>
<p>主函数 main 的返回值会返回给调用该程序的程序</p>
</li>
<li>
<p>若程序正常结束，一般将主函数的返回值设置为 0</p>
</li>
</ul>
</li>
<li>
<p>C 语言不同于脚本语言的 python，所有变量都需要先声明才能使用</p>
<ul>
<li>
<p>标识符是变量、函数或其他实体的名称（字母、数字、下划线，<strong>数字不能开头</strong>）</p>
</li>
<li>
<p>变量可以被赋值，常量不可以被赋值，直接给常量赋值是错误的</p>
</li>
</ul>
</li>
<li>
<p>printf 函数是系统自带函数，将<strong>字符串</strong>输出到控制台</p>
</li>
<li>
<p>printf = print + format ——&gt; 格式化打印</p>
</li>
<li>
<p>printf 函数是将<strong>字符串</strong>打印到控制台：</p>
<ul>
<li>只有<strong>字符串类型</strong>可以被直接打印，其他类型需要特定的占位符 (% d,% f,% c)</li>
<li>在引号内除了包含<strong>字符</strong>，还包含<strong>占位符</strong>，打印时会<strong>按顺序</strong>用<strong>变量</strong>的值<strong>代替</strong>占位符</li>
<li>例如：printf (&quot;占位 1, 占位 2, 占位 3&quot;, 变量 1, 变量 2, 变量 3);</li>
</ul>
</li>
</ol>
<h4 id="整形数据类型"><a class="anchor" href="#整形数据类型">#</a> 整形数据类型</h4>
<ol>
<li>
<p>占位符：% d</p>
</li>
<li>
<p>不同整形数据类型的<strong>占用内存</strong>大小不同，表示的<strong>数据范围</strong>也不同</p>
</li>
<li>
<p>计算机通过<strong>晶体管</strong>的开关状态记录数据</p>
<ul>
<li>
<p>通常 8 个晶体管一组，称为字节</p>
</li>
<li>
<p>每个晶体管又开关两种状态 (0,1)，<strong>二进制</strong>：一共 256 种状态</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>=</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">2^8 = 256
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span></span></span></p>
</li>
</ul>
</li>
<li>
<p>sizeof 关键词：测量实体占用<strong>字节</strong>大小</p>
</li>
</ol>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof char = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof short = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof int = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof long = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof long long = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">long</span>));</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof a = %d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof 100 = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231300001.png" alt="" /></p>
<ul>
<li>最高位为符号位：2 的七次方、2 的十五次方...</li>
<li>当确定数值为正数时，不需要最高位当作符号位使用 unsigned</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231306582.png" alt="" /></p>
<h4 id="浮点数据类型"><a class="anchor" href="#浮点数据类型">#</a> 浮点数据类型</h4>
<ol>
<li>
<p>占位符：% f、% lf</p>
</li>
<li>
<p>单精度浮点类型：float（4 个字节）</p>
</li>
</ol>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">1.234567</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">0.00001</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">3.141592385</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %f\n, b = %f\n, c = %f\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>尾数较长的浮点数会产生<strong>误差</strong>，并不能表示无限精确</li>
<li>C 语言标准规定 float 类型至少能表示<strong> 6 位有效数字</strong>：一般前六位数字准确，后面的数则会有误差</li>
</ul>
<ol start="3">
<li>双精度浮点类型：double（8 个字节）</li>
</ol>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>｛</span><br><span class="line">    <span class="type">double</span> A = <span class="number">1.234567</span>;</span><br><span class="line">    <span class="type">double</span> B = <span class="number">0.00001</span>;</span><br><span class="line">    <span class="type">double</span> C = <span class="number">3.141592385</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A = %f\n B = %f\n C = %f\n&quot;</span>, A, B, C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="变量与常量"><a class="anchor" href="#变量与常量">#</a> 变量与常量</h4>
<h5 id="数字类型"><a class="anchor" href="#数字类型">#</a> <strong>数字类型</strong></h5>
<p><strong>变量</strong></p>
<ol>
<li>标识符：自己命名，表示变量、函数或其他实体的名称，使用前需要<strong>声明</strong>
<ul>
<li>字母、数字、下划线，<strong>数字不能开头</strong></li>
<li>数据类型 标识符名称；</li>
<li>int a;</li>
</ul>
</li>
<li>关键词：C 语言标准规定词汇，可以直接使用</li>
<li>变量<strong>可以</strong>被多次<strong>赋值</strong>
<ul>
<li>下列代码可以<strong>正确运行</strong></li>
<li>允许变量被多次<strong>赋值</strong></li>
</ul>
</li>
</ol>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">a = <span class="number">200</span>;	</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>变量<strong>不可以</strong>被多次<strong>初始化</strong>
<ul>
<li>下列代码运行<strong>报错</strong> (<strong>重复声明</strong>)</li>
<li>不允许变量被多次<strong>初始化</strong></li>
</ul>
</li>
</ol>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">200</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>常量</strong></p>
<ul>
<li>
<p>常量一开始就写死，无法修改</p>
</li>
<li>
<p>字面常量：100,3.14，&quot;hello world&quot;</p>
</li>
<li>
<p>字面常量无需声明，编译器可判断类型</p>
</li>
<li>
<p>符号常量：#<strong>define</strong> <strong>符号常量名</strong> <strong>值</strong></p>
</li>
<li>
<p>出现频率较高且需要修改的值，修改时只需在常量定义处修改即可</p>
</li>
<li>
<p>打印字符串时，可以直接打印字符串常量或者使用 **% s 占位符 **，然后用字符串实体替换</p>
</li>
</ul>
<h5 id="字符类型"><a class="anchor" href="#字符类型">#</a> <strong>字符类型</strong></h5>
<p><strong>变量</strong></p>
<ol>
<li><strong>字符变量</strong>常用<strong> char</strong> 类型来表示</li>
<li><strong>字符变量</strong>只占用 1 个字节的内存</li>
</ol>
<p><strong>常量</strong></p>
<ol>
<li>字符常量由<strong>单引号</strong>包括：'a','1',' 字'</li>
<li>printf 函数<strong>只能</strong>输出<strong>字符串</strong>，所以输出单个字符时同样需要在字符串中使用<strong>占位符</strong>：% c</li>
</ol>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c%c&quot;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;z&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>字符<strong>常量</strong>内存大小
<ul>
<li>使用<strong> C 编译器</strong>的.c 文件中，<strong>字符常量</strong>占 4 个字节</li>
<li>使用<strong> C++ 编译器</strong>的.cpp 文件中，<strong>字符常量</strong>占 1 个字节</li>
</ul>
</li>
</ol>
<h4 id="整数与字符的关系ascii"><a class="anchor" href="#整数与字符的关系ascii">#</a> 整数与字符的关系 ASCII</h4>
<ol>
<li><strong>字符类本质型就是整形类型</strong>
<ul>
<li>将字符类型命名为 char，只占 1 个字节，既能用于整形，又能用于字符类型</li>
<li>字符类型 char 同样可以使用 +-*/，会对应到其所表示的 ASCII 码</li>
<li>使用 **&quot;% c&quot;<strong> 占位符 ——&gt; 输出</strong>字符类型 **</li>
<li>使用 **&quot;% d&quot;<strong> 占位符 ——&gt; 输出对应</strong>整形 **</li>
</ul>
</li>
<li>当使用整形占位符输出字符类型时</li>
</ol>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231310357.png" alt="image-20220823131046292" /></p>
<ol start="3">
<li>
<p>所以字符和数字存在一对一的映射关系（美国信息交换标准代码 ASCII）</p>
</li>
<li>
<p><strong>ACSII 编码：</strong></p>
</li>
<li>
<p>CHAR：数值对应字符</p>
</li>
<li>
<p>HEX：十六进制</p>
</li>
<li>
<p>OCT：八进制</p>
</li>
<li>
<p>DEC：十进制</p>
</li>
<li>
<p>转换大小写</p>
</li>
</ol>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> letter = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, letter + <span class="number">32</span>);</span><br></pre></td></tr></table></figure></p>
<ol start="6">
<li>
<p><strong>字符串的字节长度 = 字符个数 + 1</strong></p>
<ol>
<li>字符串末尾会默认添加一个结束符</li>
<li>每个字符占一个字节 + <strong>末尾的結束字符</strong> (标记字符串结束)</li>
<li><strong>数值 0</strong>：用于表示字符串结束，注意是<strong>数值 0</strong>，而不是<strong>字符 0</strong></li>
</ol>
</li>
<li>
<p><strong>\ 数值：转移字符</strong></p>
<ol>
<li><strong>转义字符</strong>只占 ASCII 中的<strong>一个字符</strong></li>
<li>直接在字符串中写<strong> 0</strong>——&gt;<strong> 字符 0</strong></li>
<li>在字符串中使用转移字符 **\0**——&gt;<strong> 数值 0 (字符串结束标识符)</strong></li>
<li><strong>结束符：\0</strong></li>
</ol>
</li>
<li>
<p><strong>转义字符斜杠后的数值是用八进制表示：\ 数值 (八进制)</strong></p>
<ul>
<li><strong>OCT('H')=110、OCT('e')=145、OCT('l')=154、OCT('o')=157</strong></li>
<li>printf(&quot;\110\145\154\154\157&quot;);——&gt;&quot;Hello&quot;</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231306290.png" alt="" /></p>
<ul>
<li><strong>不可见字符</strong>：既可以用 **\ 字母<strong>也可以用</strong> \ 数值 (八进制)**</li>
</ul>
</li>
</ol>
<h4 id="printf函数"><a class="anchor" href="#printf函数">#</a> printf 函数</h4>
<ol>
<li>
<p>格式：printf (&quot;占位符 1&quot;, 占位符 2&quot;, 替换 1, 替换 2)</p>
<ul>
<li><strong>printf</strong> 函数的第<strong>一个参数</strong>是<strong>字符串</strong> ——&gt; 是需要输出的内容</li>
<li><strong>printf</strong> 函数<strong>第二以及后续参数</strong>都将<strong>依次</strong>替换<strong>占位符</strong></li>
<li><strong>占位符的类型和数量</strong>要和<strong>后续参数的类型和数量</strong>一一对应</li>
</ul>
</li>
<li>
<p><strong>当 printf 占位符的格式与后续参数的格式不相同时，输出为 0</strong></p>
<ul>
<li><strong>特例：字符类型的本质是整形 (ASCII)，可以正常输出字符和整数的映射关系</strong></li>
<li><strong>如果整形变量的格式规范设置为 % f，输出为 0</strong></li>
<li><strong>如果浮点类型变量的格式规范设置为 % d，同样输出为 0</strong></li>
</ul>
</li>
<li>
<p>printf 是可变参数函数，参数传入到函数的可变参数中，变量会发生自动<strong>类型提升</strong></p>
<ul>
<li>char 和 short 会被提升为 int——&gt;<strong>char、short、int</strong> 均<strong>可以使用 % d 占位符</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231328426.png" alt="image-20220823132831339" /></p>
<ul>
<li>无符号类型<strong> unsigned</strong> 同理，用 u 表示则最高位不会被当作符号字符</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231327076.png" alt="image-20220823132742979" /></p>
</li>
</ol>
<h4 id="转换规范占位符"><a class="anchor" href="#转换规范占位符">#</a> 转换规范 (占位符)</h4>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231335113.png" alt="image-20220823133506073" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231335323.png" alt="image-20220823133523280" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231335027.png" alt="image-20220823133555984" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231336404.png" alt="image-20220823133612364" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231336077.png" alt="image-20220823133627035" /></p>
<h5 id="转换类型"><a class="anchor" href="#转换类型">#</a> <strong>转换类型</strong></h5>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231337299.png" alt="image-20220823133753254" /></p>
<h5 id="长度指示符"><a class="anchor" href="#长度指示符">#</a> <strong>长度指示符</strong></h5>
<ul>
<li><strong>% d ——&gt; % ld 或 % lld 扩展到 long/long long</strong></li>
<li><strong>% d ——&gt; % hd 或 % hhd 收缩到 short/char</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231352919.png" alt="image-20220823135210872" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231352578.png" alt="image-20220823135234532" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231353238.png" alt="image-20220823135349191" /></p>
<h5 id="转换精度"><a class="anchor" href="#转换精度">#</a> <strong>转换精度</strong></h5>
<ul>
<li><strong>整数类型 ——&gt; 控制最小数字位数</strong></li>
<li><strong>浮点类型 ——&gt; 控制小数点后位数</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231410402.png" alt="image-20220823141018341" /></p>
<h5 id="最小字段宽度"><a class="anchor" href="#最小字段宽度">#</a> <strong>最小字段宽度</strong></h5>
<ol>
<li><strong>达到最小宽度则不做处理</strong></li>
<li><strong>未达到最小宽度则补充空格</strong></li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231413882.png" alt="image-20220823141309829" /></p>
<h5 id="转换标志"><a class="anchor" href="#转换标志">#</a> <strong>转换标志</strong></h5>
<ol>
<li><strong>转换标志按顺序为：-+0#</strong></li>
<li><strong>0：设置 0 作为填充字符</strong> ——&gt; 最小宽度不足默认是空格填充</li>
<li><strong>-：设置 - 可使输出左对齐</strong> ——&gt; 输出默认为右对齐</li>
<li><strong>+：设置输出结果产生符号</strong> ——&gt; 正数 +、负数 -</li>
<li><strong>#：给进制前添加对应符号</strong> ——&gt;(O) 八进制、(OX) 十六进制</li>
</ol>
<h4 id="scanf函数"><a class="anchor" href="#scanf函数">#</a> scanf 函数</h4>
<ol>
<li>printf 函数：在控制台输出字符</li>
<li>scanf 函数：在控制图输入字符</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231443115.png" alt="image-20220823144321064" /></p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%hhd %hd %d %lf %llf%&quot;</span>, %a, %b, %c, %d, %e);</span><br></pre></td></tr></table></figure></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231449995.png" alt="image-20220823144910948" /></p>
<ol start="3">
<li>输入时也要根据转换规范按要求输入
<ul>
<li><strong>转换规范中以什么符号进行分割，输入时也要以相同符号分割</strong></li>
</ul>
</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231451832.png" alt="image-20220823145121781" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231451310.png" alt="image-20220823145151259" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231453046.png" alt="image-20220823145353994" /></p>
<ol start="4">
<li>
<p>转换为二进制并存储到变量</p>
<ul>
<li><strong>scanf 函数将输入的字符串按照对应转换规范进行转换</strong></li>
<li><strong>转换完成后的二进制编码，将依次存放到后续参数的变量地址中</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231501762.png" alt="image-20220823150136708" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231504681.png" alt="image-20220823150448624" /></p>
</li>
<li>
<p>将输入的字符 'A' 转换为字符类型 'A'</p>
<ul>
<li><strong>将字符 A 转换为整形和字符类形输出：A——&gt;65,'A'</strong></li>
<li><strong>若输入字符 '65',% c 只能接受第一位字符 '6','6'——&gt;56,'6'</strong></li>
</ul>
</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231510180.png" alt="image-20220823151003141" /></p>
<ol start="6">
<li>将输入的字符 '65' 转换为整数的字符类型 '65'
<ul>
<li><strong>将字符 '65' 转换为和字符类型输出：'65'——&gt;65,'A'</strong></li>
<li><strong>输入其他非数值字符则格式不正确，只能输出 0</strong></li>
</ul>
</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231543611.png" alt="image-20220823154303574" /></p>
<ol start="7">
<li><strong>总结</strong> (很重要，暂且这样分析！！)
<ul>
<li><strong>%c</strong>：只可以接受<strong>一个</strong>字符，<strong>%hhd</strong>：只可以接受<strong>数值字符</strong></li>
<li>字符 'A' 和数值字符 '65' 是<strong>等价的</strong></li>
</ul>
</li>
<li><strong>数组名即地址，所以存储到数组中，不需要地址符！！！</strong></li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231606355.png" alt="image-20220823160608316" /></p>
<h4 id="表达式和运算符"><a class="anchor" href="#表达式和运算符">#</a> 表达式和运算符</h4>
<h5 id="表达式"><a class="anchor" href="#表达式">#</a> <strong>表达式</strong></h5>
<ul>
<li>至少 1 个运算对象和至少 0 个运算符组成一个<strong>表达式</strong>（例如：100）</li>
<li>每一个表达式都有一个结果</li>
<li>表达式后接上<strong>分号；<strong> 构成</strong>表达式语句</strong></li>
<li>printf (&quot;% d\n&quot;, 5+10); 为函数调用表达式，5+10 是它的<strong>子表达式</strong></li>
</ul>
<h5 id="运算符"><a class="anchor" href="#运算符">#</a> <strong>运算符</strong></h5>
<ul>
<li>加减乘除 +-*/</li>
<li><strong>整形</strong>与<strong>整形</strong>相除 ——&gt;<strong> 自动构成整除，结果中的小数部分会被丢弃（截断）</strong></li>
<li>有<strong>浮点数</strong>参与相除 ——&gt; 可以保留小数部分</li>
</ul>
<h5 id="当printf占位符的格式与后续参数的格式不相同时"><a class="anchor" href="#当printf占位符的格式与后续参数的格式不相同时">#</a> 当 printf<strong> 占位符的格式</strong>与后续<strong>参数的格式不相同</strong>时</h5>
<ul>
<li><strong>特例：字符类型的本质是整形 (ASCII)，可以正常输出字符和整数的映射关系</strong></li>
<li><strong>整形和浮点类型格式混用 ——&gt; 输出结果为 0</strong>
<ul>
<li><strong>（%d,float）(%f,int)</strong></li>
</ul>
</li>
<li><strong>其他格式类型混用 ——&gt; 没有输出</strong>
<ul>
<li><strong>(% s,char)(% c, 字符串).....</strong></li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231814183.png" alt="image-20220823181430130" /></p>
<ol start="5">
<li>
<p>求余运算符：%</p>
<ul>
<li>取得两数相除的余数 ——&gt; 判断奇偶数</li>
</ul>
</li>
<li>
<p>自增自减运算符</p>
<ul>
<li>自增运算符：++</li>
<li>自减运算符：--</li>
</ul>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ++a, --b);	<span class="comment">//先执行a++和b--，然后打印自增/自减变化后的结果</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a++, b--);	<span class="comment">//先打印a和b原来的结果，然后自增/自减改变它的值</span></span><br></pre></td></tr></table></figure></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231826792.png" alt="image-20220823182655752" /></p>
</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231833229.png" alt="image-20220823183346188" /></p>
<ol start="7">
<li>产生额外作用的发生时机
<ul>
<li>VS 编译器累积所有自表达式求值后才会进行额外作用</li>
<li>GCC 编译器每完成一个子表达式就会立即产生额外作用</li>
<li>但都有相同的最晚发生时机：完整表达式求值结束后进入下一段代码之前</li>
<li>所以要避免在一个表达式中重复对一个变量进行自增 / 自减</li>
</ul>
</li>
<li>多元运算符
<ul>
<li>一元运算符：只有一个运算对象，自增、自减</li>
<li>二元运算符：有两个运算对象，赋值、加减乘除</li>
</ul>
</li>
<li>运算符优先级</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208231848293.png" alt="image-20220823184827249" /></p>
<h4 id="自动类型转换终极总结"><a class="anchor" href="#自动类型转换终极总结">#</a> 自动类型转换 (终极总结)</h4>
<ol>
<li><strong>高级别类型的数据范围大于等于低级别类型</strong></li>
<li><strong>无符号类型等级高于自身有符号类型：unsigned int &gt; int</strong></li>
<li><strong>浮点数据类型高于所有整形数据类型： float &gt; unsigned long</strong></li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208232249696.png" alt="" /></p>
<ul>
<li>
<p><strong>C 语言会将运算符两边的类型先进行自动类型转换 ——&gt; 然后开始运算</strong></p>
</li>
<li>
<p><strong>两个不同或相同数据类型做运算</strong></p>
<ul>
<li><strong>运算符（+ - * /）</strong></li>
<li><strong>运算结果至少都会转化为 int 类型</strong></li>
<li><strong>运算符两边的数据类型都小于或等于 int 类型 ——&gt; 运算结果为：int 类型</strong></li>
<li><strong>运算符两边存在任何大于 int 类型的数据类型 ——&gt; 运算结果为：运算符两边中最高的数据类型</strong></li>
</ul>
</li>
<li>
<p><strong>应用</strong></p>
<ul>
<li><strong>整数除法：int /int——&gt;int</strong>  <strong>(运算符两边都是 int)</strong></li>
<li><strong>浮点数除法：int /float——&gt;float</strong> (<strong>float 等级&gt; int 等级</strong>)</li>
</ul>
</li>
</ul>
<p><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">5 </span>/ <span class="number">2</span> = <span class="number">2</span></span><br><span class="line"><span class="symbol">5 </span>/ <span class="number">2.0</span> = <span class="number">2.500000</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>强制类型转换</strong>
<ul>
<li>(强制转换类型) 强制转换的数据对象，例如：int (5.2)</li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208232305438.png" alt="image-20220823230501392" /></p>
<ul>
<li><strong>注意图示代码的使用的强制类型转换，只是改变运算时的临时数据对象的类型，并没有赋值改变变量自身的类型和数值</strong></li>
</ul>
<h4 id="关系运算符和逻辑运算符"><a class="anchor" href="#关系运算符和逻辑运算符">#</a> 关系运算符和逻辑运算符</h4>
<ul>
<li>
<p><strong>关系运算符</strong></p>
<ul>
<li>C 语言中用<strong> 0 表示假</strong>，用<strong> 1 表示真</strong></li>
<li>大于等于：&gt; =，小于等于：&lt; =，等于 = =，不等于：！=</li>
</ul>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">2</span>&lt;=<span class="number">0</span>&lt;=<span class="number">10</span>);	<span class="comment">//结果为真，因为两个&lt;=运算符优先级相同，从左往右执行</span></span><br></pre></td></tr></table></figure></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208232341255.png" alt="image-20220823234154197" /></p>
</li>
<li>
<p><strong>逻辑运算符</strong></p>
<ul>
<li><strong>逻辑或：||</strong></li>
<li><strong>逻辑与：&amp;&amp;</strong></li>
<li><strong>逻辑运算符优先级低于关系运算符</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208232343697.png" alt="image-20220823234355659" /></p>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208232345502.png" alt="image-20220823234530453" /></p>
<ul>
<li><strong>运算符优先级</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208232352520.png" alt="image-20220823235224466" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208232353425.png" alt="image-20220823235322371" /></p>
<ul>
<li><strong>注意： i++ &gt; ++i、逻辑非！、正负、乘除取余、加减、大于小于、等于不等于、&amp;&amp;、||、=</strong></li>
</ul>
]]></content>
      <categories>
        <category>高级编程语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础三</title>
    <url>/2022/08/26/c-yu-yan-ji-chu-san/</url>
    <content><![CDATA[<h2 id="c语言基础三"><a class="anchor" href="#c语言基础三">#</a> C 语言基础三</h2>
<h4 id="指针"><a class="anchor" href="#指针">#</a> 指针</h4>
<ul>
<li><strong>大多数情况下：认为指针即地址即可</strong></li>
<li><strong>指针本身不是地址，但指针所保存的值是一个地址，就像变量和数值的关系，变量不是一个数值，但变量保存的值是一个数字</strong></li>
</ul>
<h5 id="内存地址"><a class="anchor" href="#内存地址">#</a> 内存地址</h5>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250740748.png" alt="image-20220825074045588" /></p>
</li>
<li>
<p><strong>数据通过数据总线在 CPU 和内存间进行传输</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250742081.png" alt="image-20220825074252982" /></p>
</li>
<li>
<p><strong>将内存中的每个数据分别放到每个寄存器中</strong></p>
</li>
<li>
<p><strong>激活算数逻辑单元</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250745019.png" alt="image-20220825074530924" /></p>
</li>
<li>
<p><strong>用另一个寄存器来存放计算结果，然后将结果存放到内存中</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250746738.png" alt="image-20220825074645644" /></p>
</li>
<li>
<p><strong>每块内存地址中都由八个晶体管开关，每块内存地址都有编号</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250750731.png" alt="image-20220825075034656" /></p>
</li>
<li>
<p><strong>不同的数据类型占用存储空间大小不同</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250752470.png" alt="image-20220825075214402" /></p>
</li>
<li>
<p><strong>内存地址总结</strong></p>
</li>
<li>
<p><strong>记录一个数据对象在内存地址中的位置需要两个信息：</strong></p>
<ul>
<li><strong>首地址 + 存储空间大小 (数据对象所占字节数)</strong></li>
</ul>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250755563.png" alt="image-20220825075521476" /></p>
</li>
</ul>
<h5 id="指针数据类型"><a class="anchor" href="#指针数据类型">#</a> 指针数据类型</h5>
<ul>
<li>
<p><strong>取地址运算符：&amp;</strong></p>
<ul>
<li>
<p><strong>在数据对象左边加上地址符 &amp;，即可获取数据对象的内存地址 (首地址 + 存储空间大小)</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250802418.png" alt="image-20220825080242349" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250804744.png" alt="image-20220825080420683" /></p>
</li>
<li>
<p><strong>声明指针变量时：空格位置不同都是正确的</strong></p>
</li>
<li>
<p><strong>int * p;		// 空格在 * 左边</strong><br />
<strong> int * p;		// 空格在 * 右边</strong><br />
<strong> int * p;		// 没有空格</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>指针值 = 对象首地址</strong></p>
</li>
<li>
<p><strong>数据类型 ——&gt; 指针类型 ——&gt; 存储空间大小</strong></p>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250808035.png" alt="image-20220825080857964" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250810984.png" alt="image-20220825081044923" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250813062.png" alt="image-20220825081305997" /></p>
</li>
</ul>
</li>
<li>
<p><strong>取值运算符：</strong>*</p>
<ul>
<li>
<p><em><em>在指针对象左边加上取值运算符</em>，即可根据内存地址 (首地址 + 空间大小) 找到数据对象</em> *</p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250829229.png" alt="image-20220825082906168" /></p>
</li>
<li>
<p><strong>可以通过：对数据地址取值来访问数据对象</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250833689.png" alt="image-20220825083357629" /></p>
</li>
</ul>
</li>
</ul>
<h5 id="不同指针类型"><a class="anchor" href="#不同指针类型">#</a> 不同指针类型</h5>
<ul>
<li>
<p><strong>不同指针类型所表示的数据对象的 (内存的存储空间大小) 不同 ——&gt; 不可以相互赋值</strong></p>
</li>
<li>
<p><strong>不同指针类型所表示的数据对象的 (内存的存储空间大小不同)，但是指针本身所占用的空间大小可能相同</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250848272.png" alt="image-20220825084852196" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250849760.png" alt="image-20220825084933710" /></p>
</li>
</ul>
<h5 id="强制转化指针类型"><a class="anchor" href="#强制转化指针类型">#</a> 强制转化指针类型</h5>
<ul>
<li>
<p><strong>强制转换指针类型 ——&gt; 指针保存 (数据对象的首地址) 并不会变</strong></p>
</li>
<li>
<p><strong>强制转换指针类型 ——&gt; 但是指针表示的 (数据对象的存储空间大小) 发生改变</strong></p>
</li>
<li>
<p><strong>不同类型的指针在取值 (星 指针) 时，从 (指针所保存的首地址) 开始向后取出 (指针类型所表示的存储空间大小) 的数据</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250901975.png" alt="image-20220825090139913" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250902780.png" alt="image-20220825090228704" /></p>
</li>
<li>
<h5 id="指针小总结"><a class="anchor" href="#指针小总结">#</a> <strong>指针小总结</strong></h5>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250909957.png" alt="image-20220825090917903" /></li>
<li><strong>指针保存了数据对象的首地址和存储空间大小</strong></li>
<li><strong>指针值 = 数据对象首地址</strong></li>
<li><strong>指针类型 ——&gt; 数据对象的存储空间大小</strong></li>
<li><strong>不同类型指针在取值 (星 指针) 时，从 (保存的首地址) 开始向后取出 (不同存储空间大小) 的数据</strong></li>
</ul>
</li>
</ul>
<h4 id="指针运算"><a class="anchor" href="#指针运算">#</a> 指针运算</h4>
<h5 id="指针类型与整形相加减"><a class="anchor" href="#指针类型与整形相加减">#</a> 指针类型与整形相加减</h5>
<ul>
<li>
<p><strong>指针类型与整形相加减 ——&gt; 移动指针内保存的首地址</strong></p>
</li>
<li>
<p><strong>无法将整形数据 赋给 指针类型</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250912423.png" alt="image-20220825091207365" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250911298.png" alt="image-20220825091142239" /></p>
</li>
<li>
<p><strong>将数值强行转换为指针类型</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250916406.png" alt="image-20220825091645350" /></p>
<ul>
<li><strong>不同指针的首地址相同，但其所表示的空间大小不同</strong></li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250919089.png" alt="image-20220825091947034" /></li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250921388.png" alt="image-20220825092109330" /></li>
<li><strong>不同类型指针所表示的连续的地址间隔不同（因为所保存的数据类型的存储空间不同）</strong></li>
</ul>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250921296.png" alt="image-20220825092158225" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250924469.png" alt="image-20220825092429404" /></p>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250924396.png" alt="image-20220825092451338" /></p>
<h5 id="同类型指针减法运算"><a class="anchor" href="#同类型指针减法运算">#</a> 同类型指针减法运算</h5>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250932611.png" alt="image-20220825093228555" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250934550.png" alt="image-20220825093441483" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250938020.png" alt="image-20220825093848961" /></p>
</li>
</ul>
<h5 id="指针运算总结"><a class="anchor" href="#指针运算总结">#</a> 指针运算总结</h5>
<ul>
<li>
<p><strong>有实际意义的指针运算 ——&gt; 不会报错</strong></p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250939984.png" alt="image-20220825093953935" /></li>
</ul>
</li>
<li>
<p><strong>没有实际意义的指针运算 ——&gt; 会报错</strong></p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250940393.png" alt="image-20220825094056340" /></li>
</ul>
</li>
</ul>
<h4 id="指针与数组"><a class="anchor" href="#指针与数组">#</a> 指针与数组</h4>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251023129.png" alt="image-20220825102329063" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251023798.png" alt="image-20220825102353739" /></p>
</li>
<li>
<p><strong>数组首地址</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251025238.png" alt="image-20220825102530190" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251027554.png" alt="image-20220825102707495" /></p>
</li>
</ul>
<h5 id="数组名与指针的关系"><a class="anchor" href="#数组名与指针的关系">#</a> 数组名与指针的关系</h5>
<ul>
<li>
<p><strong>大多数情况下，数组名会转换成指向 (数组第一个元素的地址) 的指针</strong></p>
</li>
<li>
<p><strong>对数组名使用 sizeof 和使用 地址符 &amp; 时：不会将数组名转换为指针</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251034291.png" alt="image-20220825103442228" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251035189.png" alt="image-20220825103552115" /></p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251040824.png" alt="image-20220825104000774" /></li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251040925.png" alt="image-20220825104025870" /></li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251040973.png" alt="image-20220825104035911" /></li>
</ul>
</li>
</ul>
<h5 id="指针访问数组"><a class="anchor" href="#指针访问数组">#</a> 指针访问数组</h5>
<ul>
<li>
<p><strong>访问数组元素的两种方法</strong></p>
<ul>
<li><strong><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251042276.png" alt="image-20220825104222214" /></strong></li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251043172.png" alt="image-20220825104329125" /></li>
</ul>
</li>
<li>
<p><strong>下标运算符 [] 的优先级高于一切</strong></p>
</li>
<li>
<p><strong>下标运算符最终会展开为指针的形式 ——&gt; 指针访问数组 = 下标访问数组</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251051468.png" alt="" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251048813.png" alt="image-20220825104800762" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251048756.png" alt="image-20220825104833697" /></p>
</li>
<li>
<p>arr[2] ——&gt; *(arr+2)<br />
[2]arr ——&gt; *(2+arr)</p>
</li>
</ul>
<h5 id="指针作为参数传递"><a class="anchor" href="#指针作为参数传递">#</a> 指针作为参数传递</h5>
<ul>
<li>
<p><strong>实参与形参相互独立（内存地址不同）</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251134932.png" alt="image-20220825113410866" /></p>
</li>
<li>
<p><strong>形参和实参相互独立 ——&gt; 形参中的参数值，无论如何变化都不会影响实参中的参数值</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251136227.png" alt="image-20220825113619153" /></p>
</li>
<li>
<p><strong>指针作为参数传递</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251316211.png" alt="image-20220825131640155" /></p>
</li>
<li>
<p><strong>将指针传递到函数内部，函数就可以通过指针 (所指向的内存地址) 访问到数据对象，并对数据对象的值进行修改</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251321127.png" alt="image-20220825132121058" /></p>
</li>
<li>
<p>*<em> 注意，是对指针所指向的 (数据对象的值)—(<em>指针) 进行修改，而不是对指针值 (数据对象的内存地址)—(指针) 进行修改</em></em></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251326487.png" alt="image-20220825132649418" /></p>
</li>
<li>
<p><strong>scanf 函数无法直接修改 main 函数中的变量，而是通过指针 / 地址间接修改变量的值</strong></p>
</li>
<li>
<p><strong>之所以在主函数 main 中调用 scanf 函数时，scanf 函数可以改变外部 (main 函数中) 的变量，是因为 scanf 函数中传递的参数是一个地址 / 指针（参数前需要地址符 &amp;）</strong></p>
</li>
<li>
<p><strong>所以 scanf 输入函数会先读取从键盘中输入，转化后再将其存放到指针 / 地址所指向的数据对象（参数前需要地址符 &amp;）</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251334188.png" alt="image-20220825133434136" /></p>
</li>
</ul>
<h5 id="void类型指针"><a class="anchor" href="#void类型指针">#</a> void * 类型指针</h5>
<ul>
<li>
<p><strong>不同类型指针赋值会修改数据对象的类型 ——&gt; 不能相互赋值</strong></p>
<ul>
<li>
<p><strong>因为指针包括了数据对象的首地址和数据对象的存储空间 ——&gt; 不同类型指针不能相互赋值</strong></p>
</li>
<li>
<p><strong>首地址可以相同，但是存储空间不一致</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251342200.png" alt="image-20220825134239138" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251341313.png" alt="image-20220825134101255" /></p>
</li>
</ul>
</li>
<li>
<p><strong>void 类型指针没有类型 ——&gt; 仅仅保存数据对象的首地址，不保存存储空间大小</strong></p>
</li>
<li>
<p><strong>因此任意类型的指针都可以直接赋值给 void 类型指针</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251348704.png" alt="image-20220825134815645" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251346184.png" alt="image-20220825134600114" /></p>
</li>
<li>
<p><strong>由于 void 类型指针没有存储空间大小</strong></p>
</li>
<li>
<p><strong>所以任何指针类型都可以直接将地址赋给 void 类型指</strong></p>
</li>
<li>
<p><strong>但 void 类型指针要先强制转换后才能将地址赋给对应类型指针</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251357276.png" alt="image-20220825135717210" /></p>
</li>
<li>
<pre class=" language-language-c"><code class="language-language-c"># include"stdio.h"
int main()&#123;
    int a = 8;
    int *A = &a;
    printf("%d\n", A);
    printf("%d\n", *A);
    void *B = A;
    int *C = (int*)B;
    printf("%d\n", B);
    printf("%d\n", C);
&#125;
</code></pre>
</li>
<li>
<p><strong>总结</strong></p>
</li>
<li>
<p><strong>所有类型的指针都可以直接将其指向的地址赋值给 void 类型的指针</strong></p>
</li>
<li>
<p><strong>但是 void 类型指针要先强制转换类型才能将地址赋给其他类型指针</strong></p>
</li>
<li>
<p><strong>void 类型指针只能用于地址的传递，不能对地址取值 ——&gt; 只能打印 void 类型指针的地址 (数据对象地址)</strong></p>
</li>
<li>
<p><strong>因为 void 类型指针没有类型 ——&gt; 不能打印地址的取值 (数据对象的值)</strong></p>
</li>
</ul>
<h4 id="多级指针"><a class="anchor" href="#多级指针">#</a> 多级指针</h4>
<ul>
<li><strong>指针作为一个数据对象也有自己的存储位置 (地址)</strong></li>
<li><strong>指向指针的指针 = 多级指针</strong></li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251431358.png" alt="image-20220825143152294" /></li>
<li><strong>二级指针的声明</strong>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251448678.png" alt="image-20220825144843604" /></li>
</ul>
</li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251449877.png" alt="image-20220825144927815" /></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251450515.png" alt="image-20220825145007456" /></p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251450778.png" alt="image-20220825145028720" /></li>
</ul>
<h5 id="指针数组"><a class="anchor" href="#指针数组">#</a> 指针数组</h5>
<ul>
<li>
<p><strong>元素为指针的数组</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251455578.png" alt="image-20220825145507501" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251457339.png" alt="image-20220825145744263" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251455217.png" alt="image-20220825145542152" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251532143.png" alt="image-20220825153227051" /></p>
</li>
</ul>
<h5 id="从函数中返回指针"><a class="anchor" href="#从函数中返回指针">#</a> 从函数中返回指针</h5>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251534443.png" alt="image-20220825153447378" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251535637.png" alt="image-20220825153549578" /></p>
</li>
<li>
<p><strong>static 类似与 python 中的 global，使用 static 的变量将不会被系统回收</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251536530.png" alt="image-20220825153649469" /></p>
</li>
</ul>
<h5 id="将二级指针作为函数参数"><a class="anchor" href="#将二级指针作为函数参数">#</a> 将二级指针作为函数参数</h5>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251540021.png" alt="image-20220825154050938" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251541135.png" alt="image-20220825154129081" /></p>
</li>
<li>
<p><strong>将指针初始化为 NULL / 0 是一个非常好的习惯</strong><br />
 int *a = NULL;<br />
int *b = NULL;</p>
</li>
</ul>
<h4 id="指针与多维数组"><a class="anchor" href="#指针与多维数组">#</a> 指针与多维数组</h4>
<ul>
<li><strong>在一维数组中：数组的元素是一个元素 (int,char...)——&gt; 指针 (普通指针) 指向一维数组第一个 (元素的地址)</strong></li>
<li><strong>在二维数组中：数组的元素是一行一维数组 ——&gt; 指针 (数组指针) 指向二维数组中的第一个一维 (数组的地址)</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251625278.png" alt="image-20220825162539217" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251627083.png" alt="image-20220825162700032" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251627494.png" alt="image-20220825162738443" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251628868.png" alt="image-20220825162812808" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251629173.png" alt="image-20220825162924110" /></p>
<h5 id="注意区分指针数组和数组指针"><a class="anchor" href="#注意区分指针数组和数组指针">#</a> 注意区分指针数组和数组指针</h5>
<ul>
<li>
<p><strong>指针数组：是一个元素为指针的数组</strong></p>
</li>
<li>
<p><strong>数组指针：是一个指向数组的指针</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251712501.png" alt="" /></p>
</li>
<li>
<p><strong>从这里要开始注意</strong></p>
<ul>
<li><strong>普通的指针指向数组时，指向的（数组的第一个元素）的地址</strong></li>
<li><strong>而数组指针指向数组时，指向的是（一个数组）的地址</strong></li>
</ul>
<p>int* arr [20];	// 很明显这是一个指针数组 (指针类型的数组)<br />
 int (*arr)[20];		// 这是一个数组指针，为了方便理解，可以看成：int<a href="*arr">20</a></p>
</li>
</ul>
<h5 id="数组指针移动和取值"><a class="anchor" href="#数组指针移动和取值">#</a> 数组指针移动和取值</h5>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251722489.png" alt="image-20220825172205378" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251723805.png" alt="image-20220825172354700" /></p>
</li>
<li>
<p><strong>指针本身不是地址，但是指针所保存的值是一个地址</strong></p>
</li>
<li>
<p>*<em> 二维数组中的数组指针指向第一行一维数组的地址，对二维数组的第一行一维数组的地址取值 (<em>地址)——&gt; 得到了第一行一维数组</em></em></p>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251736352.png" alt="image-20220825173639300" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251737451.png" alt="image-20220825173701370" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251737557.png" alt="image-20220825173725454" /></p>
</li>
<li>
<p>图中 pInt10 是一个数组指针：指向了第一行数组</p>
</li>
<li>
<p>pInt 是一个普通指针：指向了第一行数组的第一个元素</p>
</li>
</ul>
</li>
</ul>
<h5 id="指针访问与下标访问"><a class="anchor" href="#指针访问与下标访问">#</a> 指针访问与下标访问</h5>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251741802.png" alt="image-20220825174144745" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251745518.png" alt="image-20220825174525466" /></p>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208252300994.png" alt="image-20220825174344429" /></p>
</li>
<li></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251744510.png" alt="image-20220825174432457" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251748868.png" alt="image-20220825174800806" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251748942.png" alt="image-20220825174819884" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251749597.png" alt="image-20220825174942549" /></p>
<ul>
<li><strong>所以第二个不能将数组名转换为指向数组首个元素的做法：（&amp; 数组名）——&gt; 这样会取得整个数组的地址（也就是数组指针）</strong></li>
<li><strong>指针与地址的关系 = 变量名与变量值的关系一样</strong></li>
<li><strong>大多数情况：认为指针即地址即可</strong></li>
</ul>
<h5 id="指针与三位数组"><a class="anchor" href="#指针与三位数组">#</a> 指针与三位数组</h5>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251808826.png" alt="image-20220825180853744" /></p>
<h5 id="声明器"><a class="anchor" href="#声明器">#</a> 声明器</h5>
<ul>
<li>
<h6 id="数组标识符的声明"><a class="anchor" href="#数组标识符的声明">#</a> 数组标识符的声明</h6>
</li>
<li>
<p><strong>声明与使用的形式一致</strong></p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251826037.png" alt="image-20220825182605971" /></li>
</ul>
</li>
<li>
<p><strong>函数声明器</strong></p>
<ul>
<li>
<p><strong>参数名可省略参数名</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251828620.png" alt="image-20220825182838567" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251829820.png" alt="image-20220825182914772" /></p>
</li>
</ul>
</li>
<li>
<p><strong>声明器的中优先级</strong></p>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251830367.png" alt="image-20220825183009287" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251831583.png" alt="image-20220825183111525" /></p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251845415.png" alt="image-20220825184535364" /></li>
<li><strong>指针数组：</strong>
<ol>
<li><strong>数组方括号优先级第一：——&gt; 首先是一个 (数组)</strong></li>
<li><strong>指针 * 号优先级第二：——&gt; 这个 (数组) 的元素是 (指针)</strong></li>
<li><strong>int 优先级第三：——&gt; 这个 (指针) 指向 (int) 类型</strong></li>
</ol>
</li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251852604.png" alt="image-20220825185206553" /></li>
<li><strong>数组指针：</strong>
<ol>
<li><strong>括号内的 * 号优先级第一：——&gt; 首先是一个 (指针)</strong></li>
<li><strong>数组方括号优先级第二：——&gt; 这个 (指针) 指向 (数组)</strong></li>
<li><strong>int 优先级第三：——&gt;(数组) 的元素为 (int)</strong></li>
</ol>
</li>
</ul>
</li>
<li>
<p>指针数组指针</p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251858390.png" alt="image-20220825185821325" /></li>
</ul>
</li>
<li>
<p>函数指针数组</p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251900593.png" alt="image-20220825190041541" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="函数指针与数组"><a class="anchor" href="#函数指针与数组">#</a> 函数指针与数组</h5>
<ul>
<li><strong>函数指针：指向函数的指针</strong></li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251906672.png" alt="image-20220825190619610" /></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251906693.png" alt="image-20220825190636643" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251911666.png" alt="image-20220825191130615" /></p>
<ul>
<li>
<p><strong>两种通过函数指针调用函数的方法</strong></p>
<ul>
<li>*<em> 函数指针取值 (<em>指针) 即为函数</em></em></li>
<li><strong>第二种方法是一种可行的简写：直接将函数指针当做函数使用</strong></li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251911533.png" alt="image-20220825191159481" /></li>
</ul>
</li>
<li>
<p><strong>函数指针数组</strong></p>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251916565.png" alt="image-20220825191651510" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251917379.png" alt="image-20220825191725321" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251917996.png" alt="image-20220825191757943" /></p>
</li>
</ul>
</li>
</ul>
<h5 id="字符串和字符指针"><a class="anchor" href="#字符串和字符指针">#</a> 字符串和字符指针</h5>
<ul>
<li>
<p><strong>字符串结束的标志是 数值 0 而不是 字符 '0'</strong></p>
</li>
<li>
<p><strong>为了不让 数值 0 和 字符 '0' 冲突，使用转义字符 \0 表示数值 0</strong></p>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251922338.png" alt="image-20220825192235261" /></p>
</li>
<li>
<p><strong>字符串常量无法被修改</strong></p>
</li>
<li>
<p><strong>数组中的值可以修改 ——&gt; 可以用字符数组来装载字符串，然后修改字符数组中的字符</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251932522.png" alt="image-20220825193213458" /></p>
</li>
</ul>
</li>
<li>
<p><strong>能否正常结尾的字符串（字符串末尾自带结束符 \0）</strong></p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251928369.png" alt="image-20220825192807290" /></li>
</ul>
</li>
<li>
<p><strong>字符数组与指针</strong></p>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251933773.png" alt="image-20220825193300708" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251933065.png" alt="image-20220825193322003" /></p>
</li>
<li>
<p><strong>指针 p 为一个移动的游标</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251933327.png" alt="image-20220825193351258" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251934539.png" alt="image-20220825193408468" /></p>
</li>
<li>
<p><strong>错误的写法</strong></p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251936779.png" alt="image-20220825193637718" /></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>使用指针处理字符串 (字符数组)</strong></p>
<ul>
<li><strong>字符串反转：将字符串中首尾对应的元素两两交换</strong></li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251943399.png" alt="image-20220825194328346" /></li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208251944049.png" alt="image-20220825194407984" /></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>高级编程语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>KNN算法</title>
    <url>/2022/08/29/knn-suan-fa/</url>
    <content><![CDATA[<h1 id="knn算法"><a class="anchor" href="#knn算法">#</a> KNN 算法</h1>
<h2 id="物以类聚人以群分"><a class="anchor" href="#物以类聚人以群分">#</a> 物以类聚人以群分</h2>
<ul>
<li>看一个人怎么样，看他身边的朋友什么样即可</li>
</ul>
<ol>
<li>
<p>取所有样本 (行) 的部分特征 (data 列) 和类别标签 (label 列) 来绘制散点图<br />
 (不同类别标签的样本的颜色或形状不同)</p>
</li>
<li>
<p>引进一个新的样本 (x = 特征 1，y = 特征 2，z = 特征 3，表示类别标签 color 或 symbol)</p>
</li>
<li>
<p>计算所有样本点与新引入点的距离 (欧式距离或马氏距离等)</p>
</li>
<li>
<p>对得到的所有欧式距离做升序排列，取前 k 个数据的 (取到了与我们新引进的样本点最近的 k 个数据的索引)</p>
</li>
<li>
<p>对得到的前 k 个数据进行加权求平均 (尽管有 k 个离得近的样本，但是这 k 个距离不相同，距离越近的类别标签的权重越大，越远的类别标签权重越小)</p>
</li>
</ol>
<p>欧式距离：欧几里得距离</p>
<ul>
<li>两个样本的欧式距离 = sqrt (∑相同特征相减取平方)</li>
<li>二维情况下，每一个样本 (点) 只有 x 坐标和 y 坐标两个特征 ——&gt; 所以它们的欧式距离 = sqrt ((x1-x2)²＋(y1-y2)²)</li>
</ul>
<p>K 太大：欠拟合<br />
 K 太小：过拟合</p>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础二</title>
    <url>/2022/08/26/c-yu-yan-ji-chu-er/</url>
    <content><![CDATA[<h1 id="c语言基础二"><a class="anchor" href="#c语言基础二">#</a> C 语言基础二</h1>
<h4 id="分支流程"><a class="anchor" href="#分支流程">#</a> 分支流程</h4>
<h5 id="if-else语句"><a class="anchor" href="#if-else语句">#</a> <strong>if else 语句</strong></h5>
<ul>
<li><strong>if 语句要吧条件语句写在括号 (条件语句) 内</strong></li>
<li><strong>if 和 else 语句后面不需要冒号：</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208240002558.png" alt="image-20220824000248521" /></p>
<p><strong>复合语句</strong></p>
<ul>
<li><strong>若根据判断成立与否要执行多条语句时：需要用花括号 {} 包裹住需要执行的语句</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208240013900.png" alt="image-20220824001322847" /></p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="keyword">if</span> ((num &gt;= <span class="number">10</span>) &amp;&amp; (num &lt;= <span class="number">20</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="else-if-语句"><a class="anchor" href="#else-if-语句">#</a> <strong>else if 语句</strong></h5>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> score &lt; <span class="number">60</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> score &lt; <span class="number">80</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;优秀&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="条件表达式"><a class="anchor" href="#条件表达式">#</a> <strong>条件表达式</strong></h5>
<ul>
<li>(条件语句)? &quot;YES&quot;:&quot;NO&quot;;</li>
<li><strong>条件表达式的优先级仅高于赋值运算符，可放心使用</strong></li>
<li><strong>条件语句同样要写在括号内</strong></li>
<li><strong>成立与否的结果之间冒号：分隔</strong></li>
</ul>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> result;</span><br><span class="line">    result = (<span class="number">100</span> &gt; <span class="number">50</span>) ? <span class="string">&#x27;Y&#x27;</span>:<span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="循环流程"><a class="anchor" href="#循环流程">#</a> 循环流程</h4>
<ul>
<li><strong>程序中包含三种流程</strong></li>
<li><strong>顺序流程、分支流程、循环流程</strong></li>
</ul>
<h5 id="while循环"><a class="anchor" href="#while循环">#</a> while 循环</h5>
<p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>while 循环与条件语句类似</strong>
<ul>
<li><strong>循环条件语句要写在括号内</strong></li>
<li><strong>while 语句后面不需要冒号：</strong></li>
<li><strong>while 循环的循环条件不可以被省略</strong></li>
<li><strong>多条循环行为要写在大括号内作为复合语句</strong></li>
</ul>
</li>
<li><strong>while 循环基本使用</strong>
<ol>
<li><strong>循环开始前为计数器设置初始值</strong></li>
<li><strong>计数器与一个有限制比较作为循环条件</strong></li>
<li><strong>更新计数器</strong></li>
</ol>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208240101946.png" alt="image-20220824010100894" /></p>
<h5 id="for循环"><a class="anchor" href="#for循环">#</a> for 循环</h5>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">        print(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>for 循环与 while 循环有异同</strong>
<ul>
<li><strong>for 循环将 (计数器设置初始值；循环条件；计数器更新) 都写在了括号内</strong></li>
<li><strong>for 循环括号内的各表达式以分号；分隔</strong></li>
<li><strong>多条循环行为要写在大括号内作为复合语句</strong></li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208240118600.png" alt="image-20220824011830557" /></p>
<ul>
<li><strong>将计数器变量声明在循环体外部</strong>
<ul>
<li><strong>计数器变量为全局变量</strong></li>
<li><strong>计数器变量的值会被循环体更新</strong></li>
<li><strong>循环结束时，计数器变量的值保留，循环体外部也可以调用</strong></li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208240125526.png" alt="image-20220824012550484" /></p>
<ul>
<li>
<p><strong>将计数器变量在初始化时声明</strong></p>
<ul>
<li><strong>计数器变量为临时变量</strong></li>
<li><strong>临时变量的值会被循环体更新</strong></li>
<li><strong>循环结束时，自动清除临时变量，循环体外部无法调用</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208240128820.png" alt="image-20220824012840769" /></p>
</li>
<li>
<p><strong>for 循环括号内的三个部分可以写在其他地方，或者为空</strong></p>
</li>
<li>
<p><strong>for 循环的循环条件可以省略</strong></p>
</li>
<li>
<p><strong>当循环条件为空或永远为真时 ——&gt; 死循环</strong></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208240135111.png" alt="image-20220824013509054" /></p>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208240133191.png" alt="image-20220824013305149" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208240133175.png" alt="image-20220824013325127" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208240133352.png" alt="image-20220824013344309" /></p>
<h5 id="do-while循环"><a class="anchor" href="#do-while循环">#</a> do while 循环</h5>
<ul>
<li><strong>while 循环先判断循环条件（可能一次也执行循环行为）</strong></li>
<li><strong>do while 循环先进行循环行为（至少执行一次循环行为）</strong></li>
<li><strong>记得 do while 语句后的分号；</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208240141396.png" alt="image-20220824014136356" /></p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> password;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter password: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;password);</span><br><span class="line">    &#125; <span class="keyword">while</span> (password!=<span class="number">123456</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>do while 循环 应用</strong>
<ul>
<li><strong>常常应用于输入账号、密码</strong></li>
<li><strong>至少输入一次，若输入错误则循环输入，直至输入正确</strong></li>
</ul>
</li>
</ul>
<h5 id="嵌套循环"><a class="anchor" href="#嵌套循环">#</a> 嵌套循环</h5>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i = <span class="string">&#x27;A&#x27;</span>; i &lt;= <span class="string">&#x27;E&#x27;</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="string">&#x27;0&#x27;</span>; j &lt; <span class="string">&#x27;7&#x27;</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c%c &quot;</span>, i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208240158964.png" alt="image-20220824015813924" /></p>
<h5 id="break和continue"><a class="anchor" href="#break和continue">#</a> break 和 continue</h5>
<ul>
<li>
<p><strong>break 和 continue 只作用与其直属的上一级循环</strong></p>
</li>
<li>
<p><strong>所以嵌套循环中的每个 break 和 continue 只会作用与一个循环</strong></p>
</li>
<li>
<p><strong>break：跳出整个循环</strong></p>
<ul>
<li><strong>应用：与循环一起使用</strong></li>
<li><strong>一致输入密码，直到密码正确则跳出循环</strong></li>
</ul>
</li>
<li>
<p><strong>continue：跳过本次循环，开始一下轮的循环</strong></p>
</li>
<li>
<p><strong>while 循环的计数器更新在确定位置</strong></p>
<ul>
<li>若计数器更新在 continue 下方 ——&gt; 经过 continue 进入下一次循环后：<strong>计数器不随 i++ 更新</strong></li>
<li>若计数器更新在 break 下方 ——&gt; 经过 break 跳出循环时：<strong>计数器不会更新</strong></li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241304856.png" alt="image-20220824130411784" /></p>
<ul>
<li><strong>for 循环的计数器更新在条件语句中</strong>
<ul>
<li>经过 continue 进入下一次循环后：<strong>自动执行 i++ 计数器更新</strong></li>
<li>for 循环使用 break 跳出循环时：<strong>计数器也不会更新</strong></li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241308727.png" alt="image-20220824130821669" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241312431.png" alt="image-20220824131242382" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241313274.png" alt="image-20220824131323224" /></p>
<h4 id="多重选择语句switch"><a class="anchor" href="#多重选择语句switch">#</a> 多重选择语句 switch</h4>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241328855.png" alt="image-20220824132807801" /></p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> letter;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;letter);</span><br><span class="line">    <span class="keyword">switch</span> (letter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;alpha&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;beta&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;gamma&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;%c is error\n&quot;</span>, letter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>要注意：<strong>char 类型</strong>和<strong> int 类型</strong>都属于<strong>整形</strong>哇</li>
<li><strong>整形表达式</strong>语句写在 switch () 括号内</li>
<li>每个 case 语句后的<strong>整形常量 **** 不允许重复</strong></li>
<li>所有 switch 所包含的 case、default 都写在 switch 下的大括号 {} 内作为复合语句</li>
<li><strong>case 整形常量</strong>: <strong>—— 冒号在每条 case 语句的</strong>整形常量后面 **</li>
<li><strong>defalut:</strong> —— defalut 的<strong>后面直接接冒号:</strong></li>
<li>整形表达式中的值按顺序匹配每个 case 语句，相等则执行 case 语句下的语句</li>
<li>所有的 case 都与整形表达式中的值不相等，则执行 default：后的语句，default 语句也可以不写</li>
<li>每条 case 语句<strong>最后</strong>都要有<strong> break</strong>，否则会<strong>从满足相等条件的 case 语句开始继续按顺序 * 无条件的执行</strong>之后<strong>所有 case 下的执行语句</strong>，直至遇到<strong> break 跳出</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241346512.png" alt="image-20220824134650422" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241402408.png" alt="image-20220824140224345" /></p>
<ul>
<li>
<p><strong>在 while 循环中使用 switch 语句</strong></p>
<ul>
<li>switch 语句中 case 下的 break 至会跳出 switch 语句，不会影响 while 循环</li>
<li>continue 语句不会作用与 switch，continue 只会开始 while 循环，且不会执行 continue 下方的语句</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241404258.png" alt="image-20220824140410189" /></p>
</li>
</ul>
<h4 id="数组"><a class="anchor" href="#数组">#</a> 数组</h4>
<ul>
<li><strong>数组中的内容依次排序</strong></li>
<li><strong>数组中的数据类型必须相同</strong></li>
<li><strong>访问数组元素，数组的下表从 0 开始</strong></li>
<li><strong>可以使用赋值语句修改数组中的元素</strong></li>
<li><strong>数组的占用内存 = 数组中元素类型占用内存 * 元素个数</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241446251.png" alt="image-20220824144654126" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241447859.png" alt="image-20220824144749794" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241448545.png" alt="image-20220824144835486" /></p>
<ul>
<li><strong>变量可以被多次赋值，但不能被多次初始化</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241449078.png" alt="image-20220824144923031" /></p>
<h5 id="数组初始化"><a class="anchor" href="#数组初始化">#</a> 数组初始化</h5>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241450711.png" alt="image-20220824145047657" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241451936.png" alt="image-20220824145119884" /></p>
<ul>
<li><strong>初始化列表 {}：只能用于初始化，不能用于赋值</strong></li>
<li><strong>对数组做了初始化后，将初始化列表存入到数组中，数组多余的空间则为 0</strong></li>
<li><strong>初始化列表中若为空，则数组元素全部初始化为 0，且 0 就是不可见字符 '\0'</strong></li>
<li><strong>数组空间大小 &lt;初始化列表 ——&gt; 报错，无法执行</strong></li>
<li><strong>初始化时，不规定数组的大小，数组大小根据初始化列表中的数据来匹配</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241453349.png" alt="image-20220824145313305" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241454200.png" alt="image-20220824145406152" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241458180.png" alt="image-20220824145811137" /></p>
<h5 id="声明数组但不做初始化"><a class="anchor" href="#声明数组但不做初始化">#</a> 声明数组但不做初始化</h5>
<ul>
<li><strong>未做初始化的数组冲存放了一些无意义的数据</strong></li>
<li><strong>数组和变量一样也可以不初始化，但之后需要赋值，修改无意义的数值</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241504784.png" alt="image-20220824150423726" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241505573.png" alt="image-20220824150553518" /></p>
<ul>
<li>
<p><strong>总结：声明数组时</strong></p>
<ul>
<li>
<p><strong>可以不声明数组大小，但是要初始化</strong></p>
</li>
<li>
<p><strong>可以不初始化，但是要声明数组大小</strong></p>
</li>
<li>
<p><strong>要是既不申明数组大小又不做初始化则会报错</strong></p>
</li>
<li>
<pre class=" language-language-c"><code class="language-language-c">char str1[20];
char str2[] = &#123;&#125;;
char str3[];//既不申明数组大小又不做初始化——>报错
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">"string.h"</span></span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="type">char</span> str1[<span class="number">20</span>];</span><br><span class="line">      <span class="type">char</span> str2[] = &#123;&#125;;</span><br><span class="line">      <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str1);</span><br><span class="line">      <span class="comment">//此处需要注意是数组元素str1[i]!=&#x27;\0&#x27;,而不是i!=&#x27;\0&#x27;</span></span><br><span class="line">      <span class="keyword">while</span>(str1[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%c"</span>, str1[i]);</span><br><span class="line">          i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str2);</span><br><span class="line">      <span class="comment">//此处需要注意是数组元素str2[i]!=&#x27;\0&#x27;,而不是i!=&#x27;\0&#x27;</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str2[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">putchar</span>(str2[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="数组越界"><a class="anchor" href="#数组越界">#</a> 数组越界</h5>
<ul>
<li><strong>由于编译器不会检查数组越界，所以使用数组时要自己避免数组越界</strong></li>
<li><strong>数组越界会导致计算机其他内存中的数据被修改，或访问到非数组中的数据</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241503521.png" alt="image-20220824150303446" /></p>
<h5 id="将数组中的元素复制个另一个数组"><a class="anchor" href="#将数组中的元素复制个另一个数组">#</a> 将数组中的元素复制个另一个数组</h5>
<ul>
<li><strong>只有两种方法</strong></li>
<li><strong>其他方法都是错误的</strong>
<ol>
<li><strong>使用循环语句一个一个将数组的元素赋值给另一个列表</strong></li>
<li><strong>引入头文件 &lt;memory.h&gt; 使用 memcpy 函数进行内存复制（memory copy）</strong>
<ul>
<li><strong>memcpy (目标数组，原始数组，需要复制数据的大小)</strong></li>
<li><strong>若 原始数组 空间小于 需要复制的数据大小 ——&gt; 额外复制到一些无意义的内容</strong></li>
<li><strong>若 目标数组 空间小于 需要复制的数据大小 ——&gt; 目标数值空间不足</strong></li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241521589.png" alt="image-20220824152121511" /></li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241513159.png" alt="image-20220824151334111" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241521942.png" alt="image-20220824152146892" /></p>
<h5 id="多维数组"><a class="anchor" href="#多维数组">#</a> 多维数组</h5>
<ul>
<li><strong>数组的元素还是数组</strong></li>
<li><strong>使用嵌套循环来遍历数组</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241537928.png" alt="image-20220824153730873" /></p>
<h5 id="二维数组"><a class="anchor" href="#二维数组">#</a> 二维数组</h5>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241538931.png" alt="image-20220824153831868" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241539375.png" alt="image-20220824153940314" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241541889.png" alt="image-20220824154120834" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241541224.png" alt="image-20220824154132169" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241541752.png" alt="image-20220824154147696" /></p>
<h5 id="高维数组"><a class="anchor" href="#高维数组">#</a> 高维数组</h5>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241545443.png" alt="image-20220824154533332" /></p>
<h4 id="字符串与字符数组"><a class="anchor" href="#字符串与字符数组">#</a> 字符串与字符数组</h4>
<ul>
<li><strong>字符串末尾有一个不可见的转义符：结束标识符 \0</strong></li>
<li><strong>可以直接将字符串赋值给字符数组</strong></li>
<li><strong>可以省略字符数组的大小，由后面元素数量来匹配</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241549713.png" alt="image-20220824154931663" /></p>
<h5 id="字符数组可以被直接赋值和打印"><a class="anchor" href="#字符数组可以被直接赋值和打印">#</a> 字符数组可以被直接赋值和打印</h5>
<ul>
<li><strong>但是只有在初始化时可以被直接赋值为字符串</strong></li>
<li><strong>也只有初始化时可以使用初始化列表 {}</strong></li>
</ul>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> arr1[<span class="number">12</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(arr1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> arr2[] = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//此处需要注意是数组元素str[i]!=&#x27;\0&#x27;,而不是下标i!=&#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span>(str[i] !=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, str[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241554578.png" alt="image-20220824155434523" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241558897.png" alt="image-20220824155806850" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241603634.png" alt="image-20220824160347589" /></p>
<h5 id="初始化列表长度小于数组长度"><a class="anchor" href="#初始化列表长度小于数组长度">#</a> 初始化列表长度小于数组长度</h5>
<ul>
<li><strong>多余的空间自动初始化为 0</strong></li>
<li><strong>遇到初始化为 0 (不可见字符 '\0') 的元素则结束</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241615395.png" alt="image-20220824161540340" /></p>
<h5 id="初始化列表长度等于数组长度"><a class="anchor" href="#初始化列表长度等于数组长度">#</a> 初始化列表长度等于数组长度</h5>
<ul>
<li>
<p><strong>数组全部用于存储初始化列表中的数据</strong></p>
</li>
<li>
<p><strong>没有多余的空间来存储结束标识符 '\0'</strong></p>
</li>
<li>
<p><strong>字符串无法正常结尾，打印字符串时还会打印数组以外的元素，越界访问，直至遇到一个结束符 '\0' 才会停止打印</strong></p>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241619289.png" alt="image-20220824161906242" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241621491.png" alt="image-20220824162149437" /></p>
<h5 id="初始化列表长度大于数组长度"><a class="anchor" href="#初始化列表长度大于数组长度">#</a> 初始化列表长度大于数组长度</h5>
<ul>
<li><strong>直接无法编译 ——&gt; 报错</strong></li>
</ul>
<h5 id="测量字符数组中字符串的长度"><a class="anchor" href="#测量字符数组中字符串的长度">#</a> 测量字符数组中字符串的长度</h5>
<ul>
<li><strong>使用 sizeof 测量的时内存空间大小 ——&gt; 会将字符串以外的结束符 '\0' 也算上，长度不正确</strong>
<ul>
<li><strong>可以使用循环来测量，遇到结束符时则停止计算</strong></li>
<li><strong>导入头文件 string.h，使用 strlen (str) 函数，strlen (str) 函数会测量第一个元素直到结束符 '\0' 的字符串长度</strong></li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241625930.png" alt="image-20220824162540881" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241627172.png" alt="image-20220824162746116" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241628856.png" alt="image-20220824162844790" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241629227.png" alt="image-20220824162915171" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241631264.png" alt="image-20220824163104211" /></p>
<h5 id="修改字符数组"><a class="anchor" href="#修改字符数组">#</a> 修改字符数组</h5>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241634462.png" alt="image-20220824163413417" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241635994.png" alt="image-20220824163520939" /></p>
<h5 id="输入字符串"><a class="anchor" href="#输入字符串">#</a> 输入字符串</h5>
<ul>
<li><strong>数组可以接受多个元素 ——&gt; 用字符数组接收输入的字符串</strong></li>
<li><strong>数组名 = 数组的地址 = 数组 [0] 的地址，所以不需要加地址符 &amp;</strong></li>
<li><strong>scanf 函数会自动给输入的字符串末尾添加一个结束符 '\0'——&gt; 输入的字符串可以正常结尾</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241639806.png" alt="image-20220824163902764" /></p>
<h5 id="putchar和getchar"><a class="anchor" href="#putchar和getchar">#</a> putchar 和 getchar</h5>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str;</span><br><span class="line">    str = getchar();</span><br><span class="line">    str = str - <span class="number">32</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241643837.png" alt="image-20220824164325787" /></p>
<h4 id="输入输出缓存"><a class="anchor" href="#输入输出缓存">#</a> 输入输出缓存</h4>
<ul>
<li><strong>输出缓存是系统特性</strong>，而不是函数特性</li>
<li><strong>Windows 系统</strong>和<strong> Linux 系统</strong>使用睡眠函数执行<strong>暂停</strong>操作
<ul>
<li>Windows 系统会没给一段时间输出</li>
<li>Linux 系统则会输出第一个，之后的输出会等到最后一起输出</li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241845824.png" alt="image-20220824184536750" /></p>
<h5 id="输出缓存区"><a class="anchor" href="#输出缓存区">#</a> 输出缓存区</h5>
<ul>
<li>
<p><strong>刷新缓存 ——&gt; 将缓存中的数据发送到目的地并清空缓存</strong></p>
</li>
<li>
<p><strong>输出语句中的换行符 \n 会产生行缓存：一行输出语句结束后必须刷新缓存</strong></p>
</li>
<li>
<p><strong>在控制图输入一段需要打印字符串时：程序会将需要输出的字符串放到输出缓存区中，到特定时刻再一起显示到控制台上</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241849813.png" alt="image-20220824184919730" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241850834.png" alt="image-20220824185051759" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241854104.png" alt="image-20220824185414036" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208241900545.png" alt="image-20220824190050490" /></p>
</li>
</ul>
<h5 id="输入缓存区"><a class="anchor" href="#输入缓存区">#</a> 输入缓存区</h5>
<ul>
<li>
<p><strong>输入函数 scanf 和 getchar 属于阻塞函数，是带缓存的输入函数，只有输入回车后 \n 才能进入缓存区</strong></p>
</li>
<li>
<p><strong>输入函数读取到 \n 时，认为字符串结束了，然后就会自动在 \n 之前，字符串之后添加一个结束符 \0</strong></p>
<ol>
<li>
<p><strong>当输入缓存区没有内容时，程序将阻塞在输入函数中，等待输入字符并按 (回车 \n) 确认</strong></p>
</li>
<li>
<p><strong>按下回车 (\n) 键 ——&gt; 输入的字符串将进入输入缓存区 ——&gt; 输入函数便能从输入缓存区获取字符 (包括 \n) 并删除缓存区中以获取到的字符 ——&gt; 阻塞状态解除</strong></p>
</li>
<li>
<p><strong>阻塞状态解除便能继续向下执行代码</strong></p>
</li>
</ol>
</li>
<li>
<p><strong>getchar 和 putchar 每次都只能输入或输出一个字符</strong></p>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208242045239.png" alt="image-20220824204528112" /></p>
<ul>
<li>输入了一次字符 A 和回车 \n——&gt; 程序直接分别打印了字符 A 和回车 \n</li>
</ul>
<ol>
<li>用户输入字符 A，并按回车 \n 确认 ——&gt; 字符 A 和字符 \n 进入到了输入缓存区</li>
<li>由于输入函数 getchar 只能输入一个字符，所以输入函数 getchar 从输入缓存区中获取了第一个字符 A，并将删除缓存区中已经获取到的字符 A</li>
<li>putchar 函数输出 getchar 函数中输入的字符 A</li>
<li>再次执行输入函数 getchar，由于输入缓存区中还有字符 \n——&gt;getchar 就不需要阻塞等待输入，直接获取缓存区中的 \n 即可</li>
<li>再次执行 putchar 函数打印 getchar 获取到的字符 \n</li>
<li>程序结束</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208242103738.png" alt="image-20220824210303680" /></p>
<ul>
<li>中间再使用一个 getchar 函数来稀释缓存区中的回车 \n</li>
<li>输入一个字符 A 和回车 \n ——&gt; 打印字符 A，再次输入 B 和回车 \n——&gt; 打印字符 B</li>
</ul>
<ol>
<li>输入 A 和 \n 进入到缓存区中</li>
<li>第一个 getchar 获取缓存区中的字符 A 并删除缓存区中的字符 A——&gt; 第一个 putchar 输出 getchar 输入的字符 A</li>
<li>第二个 getchar 获取到缓存区中保留的 \n 并删除缓存区中的 \n</li>
<li>缓存区中没有内容时，程序阻塞在第三个输入函数 (阻塞函数) getchar 中，等待用户输入</li>
<li>用户输入字符 B 和回车 \n 确认后和上述 A 一致，程序结束前最后任然有一个 \n 还保留在缓存区</li>
</ol>
<ul>
<li><strong>getchar 和 scanf 都是输入函数 —— 阻塞函数</strong></li>
<li><strong>scanf 输入一行字符串</strong></li>
<li><strong>getchar 输入一个字符</strong></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208242124660.png" alt="image-20220824212438610" /></p>
<ul>
<li><strong>scanf 实现输入一行字符串</strong>
<ul>
<li><strong>阻塞状态下输入 (一行字符串 + 回车 \n) 到缓存区</strong></li>
<li><strong>scanf 从缓存区中获取一行字符串 (不包括 \n) 并在字符串末尾自动添加一个结束符 \0</strong></li>
<li><strong>最后输出一行字符串 (不换行)，且缓存区中还剩余一个 \n</strong></li>
<li><strong>若紧接着还要输入字符串，先要将缓存区中的 \n 清除</strong></li>
</ul>
</li>
</ul>
<hr />
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = getchar();</span><br><span class="line">        str[i++] = c;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>
<p><strong>while 循环 + getchar 实现输入一行字符串</strong></p>
<ul>
<li>
<p><strong>第一次循环中在 getchar 阻塞，输入 (一行字符串 + 回车 \n) 到缓存区</strong></p>
</li>
<li>
<p><strong>第一次循环 getchar 获取到缓存区中的第一个字符并存入到数组 [0] 中</strong></p>
</li>
<li>
<p><strong>第二次循环由于缓存区中还有内容，所以不进入阻塞，getchar 直接获取剩余在缓存区中的第一个字符并存放到数组 [1] 中</strong></p>
</li>
<li>
<p><strong>依次循环，直至 getchar 获取到回车 \n</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208242205818.png" alt="image-20220824220513746" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208242207817.png" alt="image-20220824220718753" /></p>
</li>
</ul>
</li>
</ul>
<h5 id="不带缓存的输入函数"><a class="anchor" href="#不带缓存的输入函数">#</a> 不带缓存的输入函数</h5>
<ul>
<li><strong>不带缓存的输入函数，按下键盘程序就能立即得到输入的字符</strong></li>
<li><strong>引入头文件 conio.h 中的 getch 函数</strong></li>
<li><strong>引入头文件 conio.h 中的 getchae 函数</strong></li>
</ul>
<h4 id="函数"><a class="anchor" href="#函数">#</a> 函数</h4>
<h5 id="函数特性以及定义"><a class="anchor" href="#函数特性以及定义">#</a> 函数特性以及定义</h5>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208242307636.png" alt="image-20220824230748563" /></p>
</li>
<li>
<p><strong>函数头中的每个参数必须指定变量类型，不能省略参数类型</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208242310181.png" alt="image-20220824231017126" /></p>
</li>
<li>
<p><strong>函数定义后需要调用，函数定义或声明必须在函数调用之前</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208242312083.png" alt="image-20220824231227020" /></p>
</li>
</ul>
<h5 id="海伦公式求三角形面积"><a class="anchor" href="#海伦公式求三角形面积">#</a> <strong>海伦公式求三角形面积</strong></h5>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208242315901.png" alt="image-20220824231544843" /></p>
</li>
<li>
<pre class=" language-language-c"><code class="language-language-c">#include "stdio.h"
#include "math.h"
int main()
&#123;
    int a, b, c;
    do
    &#123;
        printf("请分别输入三角形的三条边长\n");
        scanf("%d %d %d", &a, &b, &c);
        if (a + b > c && a + c > b && b + c > a)
        &#123;
            printf("三边可以组成三角形\n");
            float p = (a + b + c) / 2;
            float s = sqrt(p * (p - a) * (p - b) * (p - c));
            printf("三角形的面积为：%.2f", s);
        &#125;
        else
        &#123;
            printf("三边不能组成三角形\n");
        &#125;
    &#125; while (!(a + b > c && a + c > b && b + c > a));
&#125;
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **封装is_triangle和area函数**</span><br><span class="line"></span><br><span class="line">- ```<span class="function">c</span></span><br><span class="line"><span class="function">  <span class="type">int</span> <span class="title">is_triangle</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> c)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (a + b > c && a + c > b && b + c > a)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">area</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> z)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="type">float</span> p = (x + y + z) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">sqrt</span>(p * (p - x) * (p - y) * (p - z));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="返回值"><a class="anchor" href="#返回值">#</a> 返回值</h5>
<ul>
<li>
<p><strong>函数 return 返回，会 (将结果) 返回到调用函数的位置并继续执行该位置的后续代码</strong></p>
</li>
<li>
<p><strong>函数可以没有返回值 (return)，只需执行内部语句 (printf)</strong></p>
</li>
<li>
<p><strong>没有返回值 (return) 的函数可定义为 void 空类型</strong></p>
</li>
<li>
<p><strong>函数也可以没有参数，在函数参数内填入 void</strong></p>
</li>
<li>
<p><strong>return 可以在函数任意位置，一旦执行到 return，函数就会停止执行并返回</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208242350621.png" alt="image-20220824235034553" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208242350438.png" alt="image-20220824235050374" /></p>
</li>
</ul>
<h5 id="函数声明"><a class="anchor" href="#函数声明">#</a> 函数声明</h5>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208242353128.png" alt="image-20220824235322066" /></p>
</li>
<li>
<p><strong>如果在调用函数前定义了函数，可以直接调用</strong></p>
</li>
<li>
<p><strong>如果在调用函数后才定义函数，需要在调用函数之前声明有这个函数</strong></p>
</li>
<li>
<p><strong>另外：函数声明可以省略形参名，但是不可省略形参的类型，因为编译器之检查参数类型和个数</strong></p>
</li>
<li>
<pre class=" language-language-c"><code class="language-language-c">int func(int a, int b);		//编译器检测到有两个int类型的参数
int func(int, int);		//编译器检测到有两个int类型的参数
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="bullet">  -</span> <span class="strong">**函数声明的格式 = 函数定义的第一行(函数头)加分号;**</span></span><br><span class="line"><span class="bullet">  -</span> ![<span class="string">image-20220824235704861</span>](<span class="link">https://raw.githubusercontent.com/YN-XS/images/master/202208242357936.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### 参数与返回值类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**调用函数时，实参类型与形参不一致**</span></span><br><span class="line"><span class="bullet">-</span> ![<span class="string">image-20220825001108414</span>](<span class="link">https://raw.githubusercontent.com/YN-XS/images/master/202208250011485.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**调用函数时，返回值与返回类型不一致**</span></span><br><span class="line"><span class="bullet">-</span> ![<span class="string">image-20220825001214321</span>](<span class="link">https://raw.githubusercontent.com/YN-XS/images/master/202208250012384.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### 形参与实参相互独立</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**常见的可以调用函数讲实参传入形参，形参得到了实参的值，根据这个值做运算，返回一个新的值**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**相当于：实参仅仅是将自己的值赋给了函数中的形参，并让其在函数中进行运算，将结果返回**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**但是如果函数中的形参发生了变化，并不会影响函数外部的实参**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**函数中的局部变量(形参) 可以与 外部的全局变量(实参)同名，但是它们是相互独立的**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**局部变量仅仅作用于函数内部，函数执行结束后，局部变量(形参)会被自动回收**</span></span><br><span class="line"></span><br><span class="line">![<span class="string">image-20220825004623646</span>](<span class="link">https://raw.githubusercontent.com/YN-XS/images/master/202208250046719.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### 函数递归</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**函数递归 = 递推 + 回归**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**函数通常需要被另一个函数调用**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**函数自己调用自己——>函数递归**</span></span><br><span class="line"><span class="bullet">-</span> 正确的使用递归需要两个了条件：</span><br><span class="line"><span class="bullet">  1.</span> <span class="strong">**递推规则**</span></span><br><span class="line"><span class="bullet">  2.</span> <span class="strong">**递推结束条件**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**递归过程**</span></span><br><span class="line"><span class="bullet">  1.</span> 递归的最后是因为结束条件而return返回到调用函数的位置</span><br><span class="line"><span class="bullet">  2.</span> 返回到调用函数的位置后，继续执行该位置以后的代码</span><br><span class="line"><span class="bullet">  3.</span> 递归的中间部分是因为函数执行完毕而返回调用函数的部分</span><br><span class="line"><span class="bullet">  4.</span> 递归函数会接着层层回归到调用函数的位置</span><br><span class="line"><span class="bullet">  5.</span> 层层回归到最开始的函数时，同样再无后续代码——>则递归结束</span><br><span class="line"></span><br><span class="line">![<span class="string">image-20220825011057321</span>](<span class="link">https://raw.githubusercontent.com/YN-XS/images/master/202208250110399.png</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">image-20220825011235942</span>](<span class="link">https://raw.githubusercontent.com/YN-XS/images/master/202208250112021.png</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">image-20220825011340972</span>](<span class="link">https://raw.githubusercontent.com/YN-XS/images/master/202208250113060.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**总结**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">  -</span> <span class="strong">**递归有两个总体过程：递推+回归**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">  -</span> 放在递归<span class="strong">**调用前的语句**</span>将在<span class="strong">**递推过程**</span>中进行</span><br><span class="line"></span><br><span class="line"><span class="bullet">  -</span> 放在递归<span class="strong">**调用后的语句**</span>将在<span class="strong">**回归过程**</span>中执行</span><br><span class="line"></span><br><span class="line"><span class="bullet">  -</span> <span class="code">```c</span></span><br><span class="line"><span class="code">    #include "stdio.h"</span></span><br><span class="line"><span class="code">    void func(int);</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    int main()</span></span><br><span class="line"><span class="code">    &#123;</span></span><br><span class="line"><span class="code">        func(0);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    void func(int a)</span></span><br><span class="line"><span class="code">    &#123;</span></span><br><span class="line"><span class="code">        if (a == 5)</span></span><br><span class="line"><span class="code">            return;</span></span><br><span class="line"><span class="code">        printf("before:%d\n", a);</span></span><br><span class="line"><span class="code">        func(a + 1);</span></span><br><span class="line"><span class="code">        printf("after:%d\n", a);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250128459.png" alt="image-20220825012805392" /></p>
<ul>
<li>
<p><strong>递归计算阶乘</strong></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250133016.png" alt="image-20220825013341942" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250134938.png" alt="image-20220825013438873" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/202208250135422.png" alt="image-20220825013510336" /></p>
</li>
</ul>
]]></content>
      <categories>
        <category>高级编程语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/08/22/hello-world/</url>
    <content><![CDATA[<h1 id="hexo"><a class="anchor" href="#hexo">#</a> HEXO</h1>
<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo</span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting</span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub</span>.</p>
<h2 id="quick-start"><a class="anchor" href="#quick-start">#</a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="anchor" href="#create-a-new-post">#</a> Create a new post</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing</span></p>
<h3 id="run-server"><a class="anchor" href="#run-server">#</a> Run server</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server</span></p>
<h3 id="generate-static-files"><a class="anchor" href="#generate-static-files">#</a> Generate static files</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating</span></p>
<h3 id="deploy-to-remote-sites"><a class="anchor" href="#deploy-to-remote-sites">#</a> Deploy to remote sites</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment</span></p>
]]></content>
      <categories>
        <category>个人随笔</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树算法</title>
    <url>/2022/08/29/jue-ce-shu-suan-fa/</url>
    <content><![CDATA[<h1 id="决策树算法"><a class="anchor" href="#决策树算法">#</a> 决策树算法</h1>
<ul>
<li>
<p>从根节点开始一步步走到叶子节点 (决策)</p>
</li>
<li>
<p>所有数据最终都会落到叶子节点，既可以做分类也可以做回归</p>
</li>
<li>
<p>根节点：第一个选择点</p>
</li>
<li>
<p>非叶子节点和分支：中间过程</p>
</li>
<li>
<p>叶子节点：最终的决策结果</p>
</li>
</ul>
<h2 id="决策树的训练阶段"><a class="anchor" href="#决策树的训练阶段">#</a> 决策树的训练阶段</h2>
<ol>
<li>
<p>从给定的数据集构建出来一棵树 (从根节点开始选择特征，如何进行特征划分)</p>
</li>
<li>
<p>决策树测试阶段</p>
</li>
<li>
<p>输入一个样本，根据构造出来的树模型从上到下一步步决策</p>
</li>
</ol>
<ul>
<li>
<p>如何判断各个特征区分能力的强弱:</p>
<ul>
<li>根节点的特征的区分能力最强，根节点以下的节点的区分能力依次下降</li>
</ul>
</li>
</ul>
<h2 id="衡量标准熵"><a class="anchor" href="#衡量标准熵">#</a> 衡量标准 —— 熵</h2>
<p>熵：随机变量的不确定性的度量</p>
<p>(熵值越大，混乱程度越大 [杂货市场和专卖店] )</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312130964.png" alt="image-20220831213057923" /></p>
<p>pi 为某个数据在集合中的概率 (所占比例)</p>
<p>A 集合的熵值 = –(0.8×log0.8+0.2×log0.2）</p>
<p>B 集合的熵值 = –(8×0.1×log0.1+0.2×log0.2)</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312131891.png" alt="image-20220831213106850" /></p>
<p>概率 pi 的值为 [0 ：1]，在对数函数 log 中 pi 越小，函数值越大 (等同于种类多，混乱程度大（不确定性大）—&gt; 熵值大)</p>
<p>信息增益：表示特征 X 使得类 Y 的不确定性减少的程度（希望分类后，同类中一起），信息增益大 == 熵值下降多</p>
<h2 id="id3"><a class="anchor" href="#id3">#</a> ID3</h2>
<ol>
<li>
<p>根据原始数据的标签（标签 1、标签 2...），计算原始熵值</p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312131840.png" alt="image-20220831213116767" /> 对每个特征逐个计算熵值</p>
</li>
</ol>
<p>若选取的某一个特征（天气）中有三种 种类（晴天 、阴天、下雨），则分别计算该特征下三种结果中的关于原始数据标签的三个熵值，最后将三个熵值加权相加（权重为三个熵值所对应的三个特征下的结果站所有结果中的比例）便得到了该特征的熵值</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312131656.png" alt="image-20220831213124598" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312131694.png" alt="image-20220831213133644" /></p>
<ol start="3">
<li>信息增益 == 原始熵值 - 特征的熵值</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312131694.png" alt="" /></p>
<ol start="4">
<li>取信息增益最大的特征</li>
</ol>
<p>（ID3：信息增益）当特征（ID 或索引）非常稀疏，种类非常多，信息增益无法处理，于是提出了信息 C4.5 的信息增益率</p>
<h2 id="c45"><a class="anchor" href="#c45">#</a> C4.5</h2>
<p>信息增益率 == 信息增益 / 自身熵值</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312131123.png" alt="image-20220831213158083" /></p>
<h2 id="cart"><a class="anchor" href="#cart">#</a> CART</h2>
<p>基尼系数 (GINI)：同样也是 p 越小函数值越大（等同与种类越多，混乱程度越大 —&gt; 熵值越大）。</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312132354.png" alt="image-20220831213207313" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312132715.png" alt="image-20220831213213668" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312132347.png" alt="image-20220831213222297" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312132182.png" alt="image-20220831213230103" /></p>
<p>如果 遇到的特征值是一组连续值（体重），则先对这些离散值进行排序，然后不断的做二分（左边 1 个，左边 2 个，左边 3 个...）计算每一种二分后的信息增益，取信息增益最大，熵值最小（信息增益 = 原始熵值 - 特征的熵值）的分界点。这就是连续值 “离散化” 过程</p>
<h2 id="决策树剪枝策略不希望决策树过于庞大复杂防止过拟合"><a class="anchor" href="#决策树剪枝策略不希望决策树过于庞大复杂防止过拟合">#</a> 决策树剪枝策略（不希望决策树过于庞大复杂，防止过拟合）</h2>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312132069.png" alt="image-20220831213237012" /></p>
<ul>
<li>预剪枝：限制深度，叶子节点个数... 防止决策树过于庞大复杂（在建立决策树的同时进行剪枝操作）</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312132852.png" alt="image-20220831213243761" /></p>
<ul>
<li>后剪枝：（建立完决策树之后再进行剪枝 ）</li>
</ul>
<h2 id="决策树做回归标签为连续值"><a class="anchor" href="#决策树做回归标签为连续值">#</a> 决策树做回归（标签为连续值）</h2>
<p>以方差为衡量标准，方差小（偏离程度小 = 混乱程度低 = 熵值小）的划分方案好。</p>
<p>测试某一个样本时，样本的标签值则等于他所被划分类中所有数据标签的平均值</p>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>指令系统</title>
    <url>/2022/09/16/zhi-ling-xi-tong/</url>
    <content><![CDATA[<h1 id="指令系统"><a class="anchor" href="#指令系统">#</a> 指令系统</h1>
<h2 id="指令定义"><a class="anchor" href="#指令定义">#</a> 指令定义</h2>
<ul>
<li>指令又称机器指令</li>
<li>指令是计算机执行某种操作的命令，是计算机运行的最小功能单位</li>
<li>一台计算机中所有指令的集合构成了该机的指令系统，也称指令集</li>
<li>高级语言与机器语言 (指令)
<ul>
<li>高级语言的语法相同，可以在不同计算机中使用。</li>
<li>指令是机器语言，直接指导硬件进行工作，硬件在设计上往往不同</li>
<li>所以一台计算机只能执行自己的指令系统的指令</li>
</ul>
</li>
</ul>
<h2 id="指令格式"><a class="anchor" href="#指令格式">#</a> 指令格式</h2>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202209171704961.png" alt="image-20220917170436714" /></p>
<h4 id="操作码指出指令中该指令应该执行什么性质的操作和具有何种功能"><a class="anchor" href="#操作码指出指令中该指令应该执行什么性质的操作和具有何种功能">#</a> 操作码：指出指令中该指令应该执行什么性质的操作和具有何种功能。</h4>
<h4 id="地址码给出被操作的信息指令或数据的地址"><a class="anchor" href="#地址码给出被操作的信息指令或数据的地址">#</a> 地址码：给出被操作的信息（指令或数据）的地址。</h4>
<p>每条指令的操作码绝对不可以重复</p>
<ul>
<li>每条指令对应不同的操作码（类似于 id 字段，不可重复，具有标识性）</li>
</ul>
<p>####　指令字长度 (指令字长)</p>
<ul>
<li>指令字长：一条指令中所包含的二进制数</li>
<li>定长指令系统</li>
<li>变长指令系统</li>
<li>指令字长越长，地址码长度越长，可直接寻址的空间范围越大</li>
<li>指令字长越长，占用空间越大，取指令越慢</li>
</ul>
<h4 id="指令地址码"><a class="anchor" href="#指令地址码">#</a> 指令地址码</h4>
<ul>
<li>三地址指令</li>
<li>二地址指令</li>
<li>单地址指令</li>
<li>零地址指令</li>
</ul>
<h4 id="指令操作码"><a class="anchor" href="#指令操作码">#</a> 指令操作码</h4>
<ul>
<li>定长操作码</li>
<li>变长操作码</li>
</ul>
<h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3>
<p>指令长度 &gt;= 操作码位数 + 总地址码位数</p>
<ul>
<li>指令条数 &lt;= pow (2, 操作码位数)
<ul>
<li>如 16 条指令，必须有四位操作码才能容纳，pow (2,4)=16，四位二进制码刚好有 16 种组合方式，用于表示 16 条指令</li>
<li>因为每条指令的操作码都不能重复</li>
</ul>
</li>
</ul>
<p>扩展码</p>
<ul>
<li>三地址码，二地址码等。。。</li>
<li>三地址码的操作码长度 &lt; 二地址码长度</li>
<li>三地址码的操作码不能被二进制码所重复，只能用三地址码剩余的状态，若没有剩余状态，则无法设计二地址码（因为不能重复）</li>
</ul>
<h2 id="指令寻址方式"><a class="anchor" href="#指令寻址方式">#</a> 指令寻址方式</h2>
<h2 id="指令的设计"><a class="anchor" href="#指令的设计">#</a> 指令的设计</h2>
<h3 id="cisc"><a class="anchor" href="#cisc">#</a> CISC</h3>
<h3 id="risc"><a class="anchor" href="#risc">#</a> RISC</h3>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降</title>
    <url>/2022/08/29/ti-du-xia-jiang/</url>
    <content><![CDATA[<h1 id="梯度下降"><a class="anchor" href="#梯度下降">#</a> 梯度下降</h1>
<h2 id="梯度"><a class="anchor" href="#梯度">#</a> 梯度</h2>
<ul>
<li>沿某一点切线方向向上，梯度方向永远是一个上升的方向 (J (θ) 分别对各参数 θ0，θ1... 分别求偏导)</li>
</ul>
<h2 id="梯度下降-2"><a class="anchor" href="#梯度下降-2">#</a> 梯度下降</h2>
<ul>
<li>沿着梯度最陡的方向下降 = 沿着梯度方向的反方向移动</li>
</ul>
<h2 id="梯度下降法"><a class="anchor" href="#梯度下降法">#</a> 梯度下降法</h2>
<ul>
<li>沿着当前梯度方向的反方向移动一小步，再重修计算新的梯度，再沿新的梯度方向的反方向移动一小步，不断迭代，直至再最低点左右来回移动，达到饱和状态，损失值趋于稳定</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312111435.png" alt="image-20220831211058319" /></p>
<p>注意这里引进了一个目标函数，与之前的 J (θ) 不一样</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312111993.png" alt="image-20220831211128952" /></p>
<h2 id="批量梯度下降"><a class="anchor" href="#批量梯度下降">#</a> 批量梯度下降</h2>
<ul>
<li>θj 是我们初始值 (初始位置)，加上了梯度的反方向，右边是指方向<br />
随机梯度下降不靠谱</li>
</ul>
<h2 id="小批量梯度下降"><a class="anchor" href="#小批量梯度下降">#</a> 小批量梯度下降</h2>
<ul>
<li>就是不再选择所有的样本进行计算，选择小部分数据来算，式子中右边依然指方向，但在方向前乘以了一个学习率 α，表示在梯度下降方向移动了那一小步</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312112712.png" alt="image-20220831211206666" /></p>
<h2 id="损失函数loss-function"><a class="anchor" href="#损失函数loss-function">#</a> 损失函数（Loss Function ）</h2>
<ul>
<li>损失函数是定义在单个样本上的，算的是一个样本的误差</li>
</ul>
<h2 id="代价函数cost-function"><a class="anchor" href="#代价函数cost-function">#</a> 代价函数（Cost Function ）</h2>
<ul>
<li>代价函数是定义在整个训练集上的，是所有样本误差的平均，也就是损失函数的平均</li>
</ul>
<h2 id="目标函数object-function"><a class="anchor" href="#目标函数object-function">#</a> 目标函数（Object Function）</h2>
<ul>
<li>最终需要优化的函数。等于经验风险 + 结构风险（也就是 Cost Function + 正则化项）</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312113645.png" alt="image-20220831211331612" /></p>
<h2 id="scikit-learn"><a class="anchor" href="#scikit-learn">#</a> scikit-learn</h2>
<ul>
<li>损失函数：Loss = 1/2 × np.dot (预测值 - 标签值，(预测值 - 标签值.T)）</li>
<li>代价函数：computeCost (数据特征，数据标签，权重参数)，返回损失函数的平均值</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312115891.png" alt="image-20220831211507855" /></p>
<ul>
<li>
<p>梯度下降函数📉：里面使用了代价函数，返回最后的权重参数 w，和每一次迭代产生的损失值组成的数组。损失函数图像：迭代次数为 x 坐标，损失值为 y 坐标</p>
</li>
<li>
<p>导入 sklearn 模型：from sklearn.linear_model import Ridge/LinearRegression/Lasso</p>
</li>
<li>
<p>模型实例化：model = LinearRegressin ( )</p>
</li>
<li>
<p>训练模型：model.fit (x_train,y_train)</p>
</li>
<li>
<p>x_train 和 y_train 都是数组或矩阵的类型，不能是 DataFrane</p>
</li>
<li>
<p>DataFrame 转 array：df.values</p>
</li>
<li>
<p>array 转 DataFrame：np.DataFrame (array)</p>
</li>
<li>
<p>用训练好的模型预测 y_predict = model.predict (data_test)</p>
</li>
<li>
<p>画回归图像</p>
<ul>
<li>设置 x 坐标 (一般是 data_test 数据特征的测试集)，可以取全部都数据特征 data</li>
<li>设置 y 坐标 (y_predicr (刚刚设置的 x 坐标))</li>
</ul>
</li>
<li>
<p>画图<br />
 fig = plt.figure (figsize = (width,height))<br />
ax = fig.add_subplot()<br />
 ax.scatter (第一列特征 x1，标签 y，label = 特征名 1)<br />
 ax.scatter (第二列特征 x2，标签 y，label = 特征名 2)<br />
 plt.plot (选取好的 x 坐标，预测好的 y 坐标，label = 预测函数)<br />
 plt.title/xlabel/ylabel (&quot;名称&quot;,fontsize= 20)<br />
 plt.legend (loc = (0–10 的数字表示图例不同位置),fontsize = 20)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>模型的训练</title>
    <url>/2022/08/29/mo-xing-de-xun-lian/</url>
    <content><![CDATA[<h1 id="模型训练"><a class="anchor" href="#模型训练">#</a> 模型训练</h1>
<h2 id="数据预处理"><a class="anchor" href="#数据预处理">#</a> 数据预处理</h2>
<ul>
<li>
<p>初始文件为一个 csv 数据表</p>
</li>
<li>
<p>每行一个样本，最后一列为标签 label，其它列为特征 data</p>
</li>
<li>
<p>添加偏置项权重 w0 对应的 x0，x0 取 1，data.insert (列位置，列标签，数据)<br />
data.insert(0,&quot;ones&quot;,1)</p>
</li>
<li>
<p>将数据特征和数据标签划分开</p>
<ul>
<li>列数 cols = data.shape [1], 行数 row = data.shape [0]</li>
<li>x = data.iloc[:,0:cols-1]</li>
<li>y = data.iloc[:,-1:]</li>
<li></li>
</ul>
<p>调用 sklearn 即可</p>
</li>
<li>
<p>初始化权重参数：w = np.matrix (np.array ([w0,w1,w2...]))，全部取 0</p>
</li>
<li>
<p>若要画损失函数：需要调用梯度下降函数，将 (x，y，w) 传入，且 x，y，w 必须是矩阵形式才能正常运算<br />
 x.values,y.values<br />
x 和 y 从数据表中分割出来的时候都是 DataFrame 类型，去 df.values 将其数组化<br />
 x = np.matrix (x.values)<br />
y = np.matrix(y.values)</p>
</li>
</ul>
<h2 id="模型的训练与使用"><a class="anchor" href="#模型的训练与使用">#</a> 模型的训练与使用</h2>
<ul>
<li>
<p>定义 学习率 α，迭代次数 iters</p>
</li>
<li>
<p>初始化模型</p>
<ul>
<li>model = LinearRegression (训练数据特征 data，训练标签 label)</li>
</ul>
</li>
<li>
<p>预测函数</p>
<ul>
<li>model.predict = np.dot (。数据特征 data，初始权重参数 w)</li>
</ul>
</li>
<li>
<p>更新权重参数 (公式)</p>
<ul>
<li>w = w-α×(1 / 样本数量）× np.dot ((预测值 - 真实值).T, 数据特征 data）</li>
</ul>
</li>
<li>
<p>损失函数</p>
<ul>
<li>Loss = 1/2 × np.dot (预测值 - 标签值，(预测值 - 标签值.T)）</li>
</ul>
</li>
<li>
<p>梯度下降函数</p>
<ul>
<li>w , Loss = gradient_descent(α，iters)</li>
</ul>
</li>
<li>
<p>损失函数（Loss Function ）</p>
<ul>
<li>定义在单个样本上的，算的是一个样本的误差</li>
</ul>
</li>
<li>
<p>代价函数（Cost Function ）</p>
<ul>
<li>定义在整个训练集上的，是所有样本误差的平均，也就是损失函数的平均。</li>
</ul>
</li>
<li>
<p>目标函数（Object Function）</p>
<ul>
<li>定义为：最终需要优化的函数。等于经验风险 + 结构风险（也就是 Cost Function + 正则化项）</li>
</ul>
</li>
<li>
<p>损失函数：Loss = 1/2 × np.dot (预测值 - 标签值，(预测值 - 标签值.T)）</p>
</li>
<li>
<p>代价函数：computeCost (数据特征，数据标签，权重参数)，返回损失函数平均值</p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312252720.png" alt="" /></li>
</ul>
</li>
<li>
<p>梯度下降函数📉：里面使用了代价函数，返回最后的权重参数 w，和每一次迭代产生的损失值组成的数组</p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312252822.png" alt="image-20220831225226786" /></li>
</ul>
</li>
<li>
<p>损失函数图像：迭代次数为 x 坐标，损失值为 y 坐标</p>
</li>
</ul>
<ol>
<li>导入 sklearn 模型：from sklearn.linear_model import Ridge/LinearRegression/Lasso</li>
<li>模型实例化：model = LinearRegressin ( )</li>
<li>训练模型：model.fit (x_train,y_train)</li>
</ol>
<ul>
<li><strong>模型只对数组或矩阵进行运算</strong></li>
<li><strong>x_train 和 y_train 都是数组或矩阵的类型，不能是 DataFrane</strong></li>
</ul>
<ol start="4">
<li>训练完之后，模型得到了一组新的权重参数，然后我们带入数据特征 (数组或矩阵形式) 就可对其进行预测标签🏷</li>
</ol>
<ul>
<li><strong>DataFrame 转 array：df.values</strong></li>
<li><strong>array 转 DataFrame：np.DataFrame (array)</strong></li>
</ul>
<ol start="5">
<li>用训练好的模型预测 y_predict = model.predict (data_test)</li>
<li>画回归图像</li>
<li>设置 x 坐标 (一般是 data_test 数据特征的测试集)，可以取全部都数据特征 data</li>
<li>设置 y 坐标 (y_predicr (刚刚设置的 x 坐标))</li>
</ol>
<h2 id="画图"><a class="anchor" href="#画图">#</a> 画图</h2>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize = (width,height))</span><br><span class="line"></span><br><span class="line">ax = fig.add_subplot()</span><br><span class="line"></span><br><span class="line">ax.scatter(第一列特征x1，标签y，label = 特征名<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ax.scatter(第二列特征x2，标签y，label = 特征名<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(选取好的x坐标，预测好的y坐标，label = 预测函数)</span><br><span class="line"></span><br><span class="line">plt.title/xlabel/ylabel(<span class="string">&quot;名称&quot;</span>,fontsize= <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc = (<span class="string">&quot;0–10的数字表示图例不同位置&quot;</span>),fontsize = <span class="number">20</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数基础</title>
    <url>/2022/08/27/xian-xing-dai-shu-ji-chu/</url>
    <content><![CDATA[<h1 id="线性代数基础"><a class="anchor" href="#线性代数基础">#</a> 线性代数基础</h1>
<h2 id="行列式"><a class="anchor" href="#行列式">#</a> 行列式</h2>
<ul>
<li>
<p>行列式的项：行列式的每一个项，都是行列式中不同行不同列的元素的乘积，N 阶行列式有 N! 个项</p>
<ul>
<li>每一项的符号 (+-) 由下标中行排列和列排列逆序数决定</li>
</ul>
</li>
<li>
<p>行列式的定义：行列式中所有项的代数和（不同行不同列元素乘积的代数和）</p>
<ul>
<li>例如：最简单的 2 阶行列式的值是，主对角线元素的乘积 (项)* 副对角线元素的乘积 (项)，其中：主对角线元素和副对角线元素就是取自不同行不同列的元素</li>
<li>主副对角线各自的元素的乘积就是一个项 (共 2! 个项)，行列式的值为这 2! 个项的代数和 (a11 乘以 a22) 项 - (a21 乘以 a12) 项</li>
</ul>
</li>
<li>
<p>逆序数：一组数列中的<strong>每一个元素</strong>的<strong>后续元素</strong>小于自己 (逆序) 的个数，累加求和即为逆序数</p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271022144.png" alt="image-20220827102216107" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271023072.png" alt="image-20220827102323043" /></p>
</li>
<li>
<p>行列式的性质（针对行或列）：</p>
<ol>
<li>互换行或列，行列式符号改变</li>
<li>提取公因子</li>
<li>倍加</li>
<li>拆分</li>
<li>对应成比例，值为零（存在一行或一列全为零）</li>
</ol>
</li>
<li>
<p>行列式的值</p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271036168.png" alt="image-20220827103652138" /></li>
</ul>
</li>
<li>
<p>行列式展开（按行或列）</p>
<ul>
<li>余子式 M：(根据下标) 去掉所在行和列后剩下的行列式</li>
<li>代数余子式 A：(根据下标) 给<strong>余子式</strong>添加符号 (+-)</li>
<li>行列式的值：某一行 (列) 的每个元素分别乘以元素的代数余子式</li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271052110.png" alt="image-20220827105231082" /></li>
</ul>
</li>
</ul>
<h2 id="矩阵"><a class="anchor" href="#矩阵">#</a> 矩阵</h2>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271055084.png" alt="image-20220827105536041" /></li>
<li>特别注意
<ul>
<li>行列式是一个数，矩阵是一个表</li>
<li>行列式必须是（N * N 阶）的，矩阵是（N * M 阶）的（可以是方阵 N=M）</li>
</ul>
</li>
<li>矩阵和行列式的运算区别
<ul>
<li>行列式数乘：行列式的某一行 (列) 乘以一个数</li>
<li>矩阵数乘：矩阵中的每一个元素都乘以一个数</li>
<li>行列式加减：(求出结果后) 数字的加减</li>
<li>矩阵加减：同形矩阵 (同行同列的两个矩阵)，对应元素相加减</li>
<li>行列式乘除：(求出结果后) 数字的乘除</li>
<li>矩阵乘除：前行乘后列（前一个矩阵的列数必须等于后一个矩阵的行数）
<ul>
<li>(N * M) 阶 * (M * K) 阶 = (N * K) 阶</li>
</ul>
</li>
</ul>
</li>
<li>矩阵不满足交换律
<ul>
<li>运算结果涉及两个矩阵相乘的公式都不相等（AB!=BA）</li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271115559.png" alt="image-20220827111552530" /></li>
</ul>
</li>
<li>其他矩阵
<ul>
<li>转置矩阵
<ul>
<li>行变列，列变行</li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271121262.png" alt="image-20220827112111236" /></li>
</ul>
</li>
<li>伴随矩阵
<ul>
<li>伴随矩阵一定是方阵</li>
<li>伴随矩阵中的各个元素是原方阵中各个的代数余子式
<ul>
<li>(代数余子式是一个行列式)</li>
</ul>
</li>
<li>最后将代数余子式以取得原方阵转置矩阵的下标排列</li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271148357.png" alt="image-20220827114844333" /></li>
</ul>
</li>
<li>单位矩阵
<ul>
<li>单位矩阵一定是方阵</li>
<li>主对角线上的元素全为 1，其余元素全为 0</li>
<li>矩阵运算中涉及 1 的运算都要转换为单位矩阵 E</li>
<li>|E| = 1，EA = AE = A</li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271155906.png" alt="image-20220827115516878" /></li>
</ul>
</li>
<li>逆矩阵
<ul>
<li>逆矩阵一定是方阵</li>
<li>若 AB = BA = E，则 B 和 A 互为逆矩阵</li>
<li>可逆的充要条件：|A| != 0</li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271223138.png" alt="image-20220827122320109" /></li>
<li>另一种求逆矩阵的方法 (增广矩阵)：将同形的单位矩阵放在可逆矩阵右边，进行初等行变换，将原可逆转换为单位矩阵，次数右边由单位矩阵转化的新的矩阵就是可逆矩阵的逆矩阵</li>
</ul>
</li>
</ul>
</li>
<li>其他矩阵之间的关系
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271256907.jpg" alt="" /></li>
</ul>
</li>
<li><strong>总结：</strong>
<ul>
<li><strong>因为只有方阵才有行列式值</strong></li>
<li><strong>所以伴随矩阵，可逆矩阵，单位矩阵都是方阵</strong></li>
</ul>
</li>
</ul>
<h2 id="初等行变换"><a class="anchor" href="#初等行变换">#</a> 初等行变换</h2>
<ul>
<li>初等行变换是将矩阵进行变换，变换后的矩阵与原矩阵不相等</li>
<li>原矩阵 ————&gt; 变换后的矩阵 （矩阵间使用的是箭头，而不是等号）</li>
<li>初等行变换的基本操作：
<ol>
<li>换行（某两行互换位置）</li>
<li>倍乘（某一行乘以一个常数）</li>
<li>倍加（某一行加上一个另一行的倍数）</li>
</ol>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271412963.png" alt="image-20220827141236923" /></li>
</ul>
</li>
<li>阶梯型矩阵：
<ol>
<li>全零行位于最后一行</li>
<li>每行的<strong>首项</strong>是主元，主元的列位置<strong>严格向右递增</strong>
<ul>
<li>（每行从左至右连续的 0 严格增加）</li>
</ul>
</li>
<li>阶梯型矩阵不唯一</li>
</ol>
</li>
<li>最简形矩阵
<ol>
<li>每行的首项：主元为 1</li>
<li>主元所在<strong>列</strong>的其他元素都为 0</li>
<li>最简形矩阵唯一</li>
</ol>
</li>
<li>个人转换方法总结：
<ol>
<li>先应用上三角方法将矩阵转换为阶梯型矩阵</li>
<li>再应用下三角方法和初等行变换的方法，将矩阵转换为最简形矩阵</li>
</ol>
</li>
</ul>
<h2 id="矩阵的秩"><a class="anchor" href="#矩阵的秩">#</a> 矩阵的秩</h2>
<ul>
<li>矩阵的秩 = 行阶梯型矩阵的非零行的行数</li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271449986.png" alt="image-20220827144900948" />
<ol>
<li>矩阵 A 的秩 R (A) 不大于行数也不大于列数</li>
<li>若方阵的秩为方阵的行数和列数 ——&gt; 不含零行，行列式值！= 0，反之则存在零行 ——&gt; 行列式值 = 0</li>
<li>矩阵做经过转置和数乘，矩阵的秩不发生改变</li>
<li>两个矩阵相乘后的矩阵的秩不大于任何一个原矩阵的秩</li>
</ol>
</li>
</ul>
<h2 id="向量"><a class="anchor" href="#向量">#</a> 向量</h2>
<ul>
<li>一个向量是是一个 1 * N 或 N * 1 的矩阵</li>
</ul>
<ol>
<li>
<p>标量（Scalar）: 一个实数，只有大小，没有方向</p>
</li>
<li>
<p>向量（Vector）: 一组实数组成的有序数组，既有大小，也有方向</p>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271607202.png" alt="image-20220827160718175" /></p>
</li>
<li>
<p>一个<strong> N 维向量 a</strong> 是由<strong> N 个有序实数</strong>组成，a_N 是向量 a 的第 n 个分量，或第 n 维</p>
</li>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>N</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a = [a_1,a_2,a_3,...,a_N]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></p>
</li>
</ul>
</li>
</ol>
<h2 id="向量组"><a class="anchor" href="#向量组">#</a> 向量组</h2>
<ul>
<li>一个向量组是 N * M 的矩阵</li>
<li>向量组是一行或一列相同维数的向量的集合 (行向量、列向量)</li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271613974.png" alt="image-20220827161317944" /></li>
</ul>
<h2 id="向量空间"><a class="anchor" href="#向量空间">#</a> 向量空间</h2>
<p><strong>欧式空间∈向量空间 = 线性空间</strong></p>
<ul>
<li>
<p>向量空间（Vector Space）：也称线性空间（Linear Space），是由向量组成的集合，并满足以下两个条件：（一个向量组关于向量加法和数乘的运算是封闭的，这个向量组构成向量空间）</p>
<ul>
<li>向量空间是特殊的向量组（满足向量加法和数乘运算的封闭性）</li>
</ul>
<ol>
<li>向量加法 +：向量空间𝒱中的两个向量𝒂和𝒃，它们的和𝒂 + 𝒃也属于空间𝒱</li>
<li>标量乘法⋅：向量空间𝒱中的任一向量𝒂和任一标量𝑐，它们的乘积𝑐⋅𝒂也属于空间𝒱</li>
</ol>
</li>
<li>
<p>欧氏空间（Euclidean Space）：是一个常用的线性空间</p>
<ul>
<li>一个欧氏空间表示通常为ℝ𝑁，其中𝑁为空间维度（Dimension）</li>
<li>欧氏空间中的向量加法和标量乘法定义为：(其中 a，b，c，∈ℝ标量)</li>
</ul>
</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>𝑎</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>𝑎</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mo separator="true">,</mo><msub><mi>𝑎</mi><mi>𝑁</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><msub><mi>𝑏</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>𝑏</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mo separator="true">,</mo><msub><mi>𝑏</mi><mi>𝑁</mi></msub><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><msub><mi>𝑎</mi><mn>1</mn></msub><mo>+</mo><msub><mi>𝑏</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>𝑎</mi><mn>2</mn></msub><mo>+</mo><msub><mi>𝑏</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mo separator="true">,</mo><msub><mi>𝑎</mi><mi>𝑁</mi></msub><mo>+</mo><msub><mi>𝑏</mi><mi>𝑁</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[𝑎_1, 𝑎_2, ⋯ , 𝑎_𝑁 ] + [𝑏_1, 𝑏_2, ⋯ , 𝑏_𝑁 ] = [𝑎_1 + 𝑏_1, 𝑎_2 + 𝑏_2, ⋯ , 𝑎_𝑁 + 𝑏_𝑁 ]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mo>⋅</mo><mo stretchy="false">[</mo><msub><mi>𝑎</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>𝑎</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mo separator="true">,</mo><msub><mi>𝑎</mi><mi>𝑁</mi></msub><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mi>𝑐</mi><mo>⋅</mo><msub><mi>𝑎</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>𝑐</mi><mo>⋅</mo><msub><mi>𝑎</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mo separator="true">,</mo><mi>𝑐</mi><mo>⋅</mo><msub><mi>𝑎</mi><mi>𝑁</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c ⋅ [𝑎_1, 𝑎_2, ⋯ , 𝑎_𝑁 ] = [𝑐⋅𝑎_1, 𝑐⋅𝑎_2, ⋯ , 𝑐⋅𝑎_𝑁 ]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></p>
<ul>
<li>
<p>线性子空间：一个向量空间的线性子空间是这个向量空间的子集，并且满足向量空间的条件（向量加法和标量乘法），</p>
</li>
<li>
<p>线性相关与线性无关：</p>
<ul>
<li>对于线性空间 𝒱 中的取出的 N 个向量 {𝒗1 , 𝒗2 , ⋯ , 𝒗N}（这是一组向量）
<ul>
<li>线性无关：<strong>只存在全为 0</strong> 的<strong>标量</strong> 𝜆1,𝜆2,⋯,𝜆N，满足𝜆1𝒗1 + 𝜆2𝒗2 +⋯ + 𝜆N𝒗N = 0</li>
<li>任意一个向量都无法被其余的向量所表示</li>
<li>线性相关：<strong>存在任意一组不全为 0</strong> 的<strong>标量</strong> 𝜆1,𝜆2,⋯,𝜆N，满足𝜆1𝒗1 + 𝜆2𝒗2 +⋯ + 𝜆N𝒗N = 0</li>
<li>存在向量可以被其余向量所表示</li>
</ul>
</li>
<li><strong>线性相关：有无数的非零解 (对标量等比例放大 —&gt; 无数)</strong>
<ul>
<li>存在一个向量可以被其余向量所表示 ——&gt; 这个向量组组成的矩阵的秩 <strong>小于</strong> 向量的个数</li>
</ul>
</li>
<li><strong>线性无关：只有 0 解，一组线性无关的向量是一个向量空间的代表 (没有重复)</strong>
<ul>
<li>不存在可以被其余向量所表示的向量 (都是代表)——&gt; 矩阵的秩 <strong>等于</strong> 向量的个数</li>
</ul>
</li>
<li>从矩阵方面考虑：
<ul>
<li>线性相关 ——&gt;
<ul>
<li>向量组组成的矩阵的秩小于向量的个数</li>
<li>向量组组成的矩阵存在零向量 (存在可以被矩阵中其余向量所表示的向量)</li>
</ul>
</li>
<li>线性无关 ——&gt;
<ul>
<li>向量组组成的矩阵的秩等于向量的个数</li>
<li>向量组组成的矩阵不存在零向量 (不存在可以被矩阵中其余向量所表示的向量)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>极大线性无关组：</p>
<ul>
<li>
<p>从向量空间中取出一组线性无关的向量（线性无关组）</p>
</li>
<li>
<p>取出线性无关组的向量空间中剩余的每一个向量<strong>都能</strong>由这个线性无关组中的向量所表示</p>
</li>
<li>
<p>所以：从向量空间中取出的线性无关组中所包含<strong>向量数量最多</strong>的那组就是极大线性无关组</p>
</li>
</ul>
<hr />
<ul>
<li>例如：向量空间中取出一组线性无关组后，向量空间中剩余的向量中还有一个不能被这组线性无关组所表示，那么这组线性无关组不是<strong>极大</strong>线性无关组，把线性无关组无法表示的向量添加到线性无关组中，那么：线性无关组 ——&gt; 极大线性无关组</li>
</ul>
<hr />
<ul>
<li>
<p>从矩阵方面考虑：</p>
<ul>
<li>
<p>向量组组成的矩阵的秩数等于不全为零的向量的个数</p>
</li>
<li>
<p>矩阵的秩数等于向量个数 ——&gt; 矩阵中向量组是极大无关组</p>
</li>
<li>
<p>矩阵的秩数小于向量个数 ——&gt; 矩阵中向量组不是极大无关组，将矩阵中的零向量 (可以被其余向量所表示的向量) 去除后，矩阵中剩余的向量是极大无关组</p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208271728886.png" alt="image-20220827172844844" /></p>
</li>
</ul>
</li>
<li>
<p>极大线性无关组的性质：</p>
<ul>
<li>向量空间 (向量组) 的极大线性无关组不唯一，其中向量数量达到最大即可</li>
<li>向量空间 (向量组) 与它的极大无关组等价，因为向量组的所有向量都可以极大无关组 (<strong>向量代表</strong>) 进行线性表示</li>
</ul>
</li>
</ul>
</li>
<li>
<p>N 维向量、N 维向量空间、N 维向量空间的维数</p>
<ul>
<li>N 维向量：N 个实数组成的有序数组</li>
<li>N 维向量空间：N 维向量组成的向量组 (且满足向量加法和数乘 封闭性)</li>
<li>N 维向量空间的维数：极大线性无关组中所包含的向量的个数</li>
</ul>
</li>
</ul>
<h2 id="齐次线性方程组-ax-0"><a class="anchor" href="#齐次线性方程组-ax-0">#</a> 齐次线性方程组 A⋅x = 0</h2>
<ul>
<li>齐次线性方程组指的是<strong>常数项全部为零</strong>的<strong>线性方程组</strong></li>
<li>求解齐次线性方程组：A⋅x = 0
<ol>
<li>用 0 将方程组补全，未知数个数与方程组的方程数相等（行数和列数相等）</li>
<li>取出方程组的未知数系数方阵（A）</li>
<li>矩阵的秩 R (A) = 矩阵的行数 n&lt;——&gt; 只有零解（组成矩阵的向量组为极大线性无关组）</li>
<li>矩阵的秩 R (A) &lt; 矩阵的行数 n——&gt; 有 n - R (A) 个解向量（线性无关），和无穷多个解 (线性相关)
<ul>
<li>解向量：每个解向量乘以对应的行向量 ——&gt; 结果为 0</li>
</ul>
</li>
<li>每个解向量乘以系数后求和 ——&gt; 得到通解</li>
</ol>
<ul>
<li>需要自行设置值来匹配出解向量，通常设置值取 0 或 1，设置值的个数等于矩阵中<strong>零行</strong>的数量，从后往前设置</li>
</ul>
</li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208272237573.png" alt="image-20220827223705471" /></li>
</ul>
<h2 id="非齐次线性方程组ax-β"><a class="anchor" href="#非齐次线性方程组ax-β">#</a> 非齐次线性方程组：A⋅x = β</h2>
<ul>
<li>非其次线性方程组指的是：<strong>常数项不全部为零</strong>的<strong>线性方程组</strong></li>
<li>求解非其次线性方程组：A⋅x = β
<ol>
<li>取出方程组未知数系数和常数组成的增广矩阵（A : β）</li>
<li>R (A) != R (A : β) ——&gt; 方程组无解</li>
<li>R (A) = R (A : β) = n (行数) ——&gt; 方程组有唯一解</li>
<li>R (A) = R (A : β) &lt; n (行数) ——&gt; 方程组有无数解</li>
</ol>
</li>
<li>非其次线性方程组的通解 = 齐次通解 + 非其次特解</li>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208272259137.png" alt="image-20220827225903088" /></li>
</ul>
<h2 id="特征值和特征向量"><a class="anchor" href="#特征值和特征向量">#</a> 特征值和特征向量</h2>
<ul>
<li>
<p>单位矩阵 E：<strong>主对角线</strong>的元素全为 1，其余元素都为 0</p>
<ul>
<li>切记：只有<strong>主对角线</strong>有值 1</li>
</ul>
</li>
<li>
<p>求解矩阵的特征值</p>
</li>
<li>
<p>N 阶矩阵就有 N 个特征值：特征值可能存在重复，可能都不同</p>
<ol>
<li>设特征值为 λ</li>
<li>矩阵 A - λ 倍的单位向量 ——&gt; 矩阵主对角线上的所有元素减去一个 λ，得到新的矩阵：A - λ⋅E</li>
<li>将新的矩阵 (A - λ⋅E) 取行列式值：|A - λ⋅E|</li>
<li>另 | A - λ⋅E| = 0 ——&gt; 得到一个或多个特征值</li>
</ol>
</li>
<li>
<p>若有 N 个特征值相同：则称这个向量是 N 重特征值</p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208280027646.png" alt="image-20220828002703615" /></li>
</ul>
</li>
<li>
<p>求解特征向量</p>
<ol>
<li>将求得的特征值 λ 带入 (A - λ⋅E)⋅X = 0</li>
<li>非重特征值 ——&gt; 只有一个解向量 ——&gt; 只有一个特征向量 (解向量乘以系数)</li>
<li>N 阶矩阵的 C 重特征值 ——&gt; 最多 C 个线性无关解向量 ——&gt; 最多 C 个线性无关的特征向量</li>
<li>所有的解向量乘以系数后相加 ——&gt; 通解</li>
</ol>
<ul>
<li>求解向量时，需要设定几个值来表示出其中一个解（通常设置 0 和 1 来匹配出解向量）</li>
</ul>
</li>
<li>
<p>总结：</p>
<ul>
<li>求特征值：|A - λ⋅E| = 0 ——&gt; λ(特征值)</li>
<li>求特征向量：(A - λ⋅E)⋅X = 0 ——&gt; X (解向量)</li>
</ul>
<hr />
<ul>
<li>
<p>解向量自身就是一个系数为 1 的特征向量（对于非重特征值）</p>
</li>
<li>
<p>每个非重特征值只对应一个解向量 ——&gt; 一个特征向量</p>
</li>
<li>
<p>重特征值</p>
</li>
</ul>
<hr />
<ul>
<li>
<p>N 阶矩阵的 C 重特征值最多有 C 个线性无关的特征向量</p>
</li>
<li>
<p>N 阶矩阵 A 的线性无关的特征向量个数 = 线性无关的解向量的个数 = N - R (A)</p>
</li>
</ul>
<hr />
<ul>
<li>
<p>需要自行设置值来匹配出解向量，通常设置值取 0 或 1，设置值的个数等于矩阵中<strong>零行</strong>的数量，从后往前设置</p>
</li>
<li>
<p>特征向量 = 特征值对应的每个解向量乘以系数后相加</p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208280108027.png" alt="image-20220828010848979" /></p>
</li>
</ul>
</li>
</ul>
<h2 id="相似对角化"><a class="anchor" href="#相似对角化">#</a> 相似对角化</h2>
<p>只有方阵可以 (相似) 对角化<br />
不同特征值对应的特征向量一定线性无关</p>
<ol>
<li>N 阶对称阵一定可以对角化</li>
</ol>
<ul>
<li>对称阵：关于主对角线对称，矩阵转置 = 矩阵本身</li>
</ul>
<ol start="2">
<li>方阵的阶数 = 方阵特征向量的个数</li>
</ol>
<ul>
<li>无论有没有相等特征值，最终都表现为每个特征值都对应一个线性无关的特征向量，也就是方阵的阶数 = (线性无关的) 特征向量的个数</li>
</ul>
<p>相似对角矩阵</p>
<ul>
<li>可逆变换矩阵 P, 是所有特征向量的所有解向量 (系数为 1 的特征向量) 所构成的矩阵</li>
<li>矩阵 A 的相似对角矩阵 = P 逆 * A * P</li>
<li>相似对角矩阵的主对角线上的元素为所有特征值，其他元素为 0</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208292108423.png" alt="image-20220829210817323" /></p>
<h2 id="规范正交化"><a class="anchor" href="#规范正交化">#</a> 规范正交化</h2>
<p>将矩阵的每一列向量分别做规范正交化，得到新的几列向量<br />
再将新的向量构成一个矩阵 ——&gt; 得到正交矩阵</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208292303143.png" alt="202208292257053_clear" /></p>
<h2 id="二次型"><a class="anchor" href="#二次型">#</a> 二次型</h2>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208300003888.png" alt="image-20220830000345295" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208300004878.png" alt="image-20220830000410288" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208300004692.png" alt="image-20220830000429871" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208300034706.png" alt="image-20220830003450056" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208300005066.png" alt="image-20220830000449940" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208300005616.png" alt="image-20220830000537793" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208300033922.png" alt="image-20220830003314292" /></p>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/2022/08/29/xian-xing-hui-gui/</url>
    <content><![CDATA[<h1 id="线性回归"><a class="anchor" href="#线性回归">#</a> 线性回归</h1>
<ul>
<li>数据：特征（x1,x2）一般是二维数据表 (矩阵) 中除了最后一列以外的所有列。</li>
<li>目标：标签（y）一般是二维数据表 (矩阵) 中的最后一列。</li>
<li>回归方程：y (x) = w1<em>x1+w2</em>x2</li>
<li>核心目标：求解出什么样子的 w1，w2 最合适。</li>
</ul>
<ol>
<li>我们的线性方程可能并不能拟合所有的数据点，则要尽可能满足多的数据点（找到最合适的一条线（平面）来最好地拟合数据点）</li>
<li>添加一个偏置项 w0（w0 不是权重）</li>
<li>拟合的平面：h (x) = w0+w1<em>x1+w2</em>x2</li>
</ol>
<ul>
<li>
<p>我们的操作都是对矩阵做操作，由于我们新构建了一个新的偏置项 w0，导致多余出来一项 ——&gt; 无法将其转换为矩阵的表达，所以我们要给数据列也新添加一列 x0，而且 x0 这一整列都为 1，所以 w0*x0 并不会改变偏置 项 w0。</p>
</li>
<li>
<p>在数据中添加一列 1 (x0)，总而言之就是为了让数据转换成矩阵 ——&gt; 方便运算<br />
整合之后 h (x) = 累加 (0~n)[w*x]<br />
 误差 每个样本真实值和我们线性方程的预测值之间肯定会存在差异，切每个样本的差异并不相同，用 ε(i) 表示。</p>
</li>
<li>
<p>y [真实值]=h (x)[线性方程]+ε(i)</p>
</li>
</ul>
<h2 id="机器学习总结"><a class="anchor" href="#机器学习总结">#</a> 机器学习总结</h2>
<ol>
<li>给机器数据一堆 data</li>
<li>告诉目标一个目标 (函数)</li>
<li>让机器去学习什么样的参数能够最符合我们的目标，我们的目标 是希望误差 ε(i) 越小越好：预测值越接近真实值</li>
</ol>
<ul>
<li><strong>误差 ε(i)</strong>
<ul>
<li>每个误差 (i=1，2，3...，n) 是独立同分布并且服从均值为 0 方差为 θ² 的高斯分布</li>
</ul>
</li>
<li><strong>独立</strong>
<ul>
<li>每个样本的误差之间都没有关系 (所以拿到一组数据后首先要对其进行打乱 shuffer)</li>
</ul>
</li>
<li><strong>同分布</strong>：
<ul>
<li>数据尽可能都来自相同的分布</li>
</ul>
</li>
<li><strong>高斯分布 (正态分布)</strong>
<ul>
<li>有的多，有的少，均值为 0，且浮动不会太大，只有极小情况下有浮动过大</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数进阶</title>
    <url>/2022/08/28/xian-xing-dai-shu-jin-jie/</url>
    <content><![CDATA[<h1 id="线性代数进阶"><a class="anchor" href="#线性代数进阶">#</a> 线性代数进阶</h1>
<h2 id="向量"><a class="anchor" href="#向量">#</a> 向量</h2>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281005651.png" alt="image-20220828100539542" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281008859.png" alt="image-20220828100844721" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281012944.png" alt="image-20220828101247881" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281015683.png" alt="image-20220828101518624" /></p>
<h3 id="向量的加法"><a class="anchor" href="#向量的加法">#</a> 向量的加法</h3>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281027690.png" alt="image-20220828102705636" /></p>
<h3 id="向量的数乘"><a class="anchor" href="#向量的数乘">#</a> 向量的数乘</h3>
<p><strong>标量 &lt;——&gt; 数字在线性代数中的主要作用就是放缩向量</strong></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281033875.png" alt="image-20220828103312824" /><br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281041379.png" alt="image-20220828104114331" /></p>
<h2 id="向量的线性组合-张成的空间和基"><a class="anchor" href="#向量的线性组合-张成的空间和基">#</a> 向量的线性组合、张成的空间和基</h2>
<h3 id="基向量"><a class="anchor" href="#基向量">#</a> 基向量</h3>
<p>i 和 j 是 xy 坐标系的基向量，也称为 x 轴上的 i 帽和 y 轴上的 j 帽（x 和 y 轴正方向上的单位向量）<br />
i 帽和 j 帽一般为：i 帽 (1,0) T 和 j 帽 (0,1) T<br />
<strong> 将坐标看成一个标量 ——&gt; 那么基向量就是这些标量缩放的对象</strong><br />
<strong> x 坐标作用于 i 帽，y 坐标作用与 j 帽</strong><br />
用数字描述向量时都依赖于基向量<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281139764.png" alt="image-20220828113920713" /><br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281137863.png" alt="image-20220828113709803" /></p>
<h3 id="向量的线性组合"><a class="anchor" href="#向量的线性组合">#</a> 向量的线性组合</h3>
<p>两个数乘向量的和称为这两个向量的线性组合<br />
向量 = 标量 * 基向量 (单位向量)<br />
 如果让两个标量同时自由变化，则可以得到所有的向量</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281217993.png" alt="image-20220828121737882" /></p>
<p>如果固定其中一个标量不变，让另一个标量自由变化，所产生的向量的终点在一条直线上</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281146135.png" alt="image-20220828114631036" /></p>
<p>若两个基向量恰好共线：所产生的向量的终点被限制在一条过原点的直线上</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281218562.png" alt="image-20220828121834504" /></p>
<p>若两个基向量都是零向量：只能被限制在原点</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281219692.png" alt="image-20220828121902636" /></p>
<h3 id="张成的空间"><a class="anchor" href="#张成的空间">#</a> 张成的空间</h3>
<p>大部分二维向量张成的空间是二维向量的集合<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281221771.png" alt="image-20220828122144650" /></p>
<p>当二维向量共线时张成的空间则是终点落在一条直线上的向量的集合</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281311517.png" alt="image-20220828131147471" /></p>
<p>当考虑多个向量时，将每个向量抽象为它的终点，就不必考虑所有的箭头了，只需要考虑无线大的二维平面本身</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281317328.png" alt="image-20220828131723092" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281317264.png" alt="image-20220828131743142" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281318915.png" alt="image-20220828131816792" /></p>
<ul>
<li>考虑一个向量时 ——&gt; 把它看作箭头</li>
<li>考虑多个向量时 ——&gt; 把它们看作点<br />
两个向量张成的空间实际就是三维空间中一个过原点的平面
<ul>
<li>所以终点落在这个平面的向量的集合（向量的起点都是原点）<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281324411.png" alt="image-20220828132409340" /></li>
</ul>
</li>
</ul>
<p>三个数乘向量的线性组合<br />
选择三个标量，对三个向量分别进行缩放，然后吧结果相加<br />
三个向量所有的线性组合构成了它们张成的空间<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281327581.png" alt="image-20220828132758497" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281332032.png" alt="image-20220828133235965" /></p>
<h3 id="线性相关"><a class="anchor" href="#线性相关">#</a> 线性相关</h3>
<p>当有多个向量时，移除其中一个向量，而不减小张成的空间 ——&gt; 它们<strong>线性相关</strong><br />
其中一个向量可以被其他向量的线性组合所表示 &lt;—— 因为这个向量已经落在了其他向量张成的空间中</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281338017.png" alt="image-20220828133845953" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281341219.png" alt="image-20220828134109137" /></p>
<h3 id="线性无关"><a class="anchor" href="#线性无关">#</a> 线性无关</h3>
<p>所有向量都给张成的空间添加了新的维度<br />
不存在任意一个向量可以被其他向量<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281345813.png" alt="image-20220828134524728" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281351917.png" alt="image-20220828135101826" /></p>
<h3 id="向量空间"><a class="anchor" href="#向量空间">#</a> 向量空间</h3>
<p>向量空间的<strong>基向量</strong>是张成这个空间的其中<strong>一组【线性无关】的向量所组成的集合</strong></p>
<h2 id="矩阵与线性变换"><a class="anchor" href="#矩阵与线性变换">#</a> 矩阵与线性变换</h2>
<p><strong>变换本质上是（函数）的一种花哨说法</strong><br />
<strong>函数：接收输入内容 ——&gt; 输出对应结果</strong></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281838179.png" alt="image-20220828183802120" /><br />
<strong> 特别的，在线性代数的情况下：接收一个向量 ——&gt; 输出一个向量的变换</strong></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281841307.png" alt="image-20220828184116230" /></p>
<h3 id="向量的函数变换运动"><a class="anchor" href="#向量的函数变换运动">#</a> 向量的函数 ——&gt; 变换 — 运动</h3>
<p>如果一个变换接受一个向量并输出一个向量：试着想象输入向量移动 (旋转) 到输出向量的运动过程</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281902081.png" alt="image-20220828190222997" /></p>
<p>理解整个变换：每一个输入向量都移动到对应输出向量的位置</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281906469.png" alt="image-20220828190610202" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281905948.png" alt="image-20220828190518637" /></p>
<p>将向量看作箭头时，同时考虑所有二维向量会变得很拥挤，可以将每个向量的重点来看作这个向量</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281908439.png" alt="image-20220828190808320" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281908445.png" alt="image-20220828190835332" /></p>
<p>对无线网格上的所有点同时做变换</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281910080.png" alt="image-20220828191000968" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281910372.png" alt="image-20220828191024168" /></p>
<p>同时保留每个向量变换前的终点和变换后的终点，追踪它们的相对关系</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281912858.png" alt="image-20220828191230701" /></p>
<h3 id="线性变换的要求"><a class="anchor" href="#线性变换的要求">#</a> 线性变换的要求</h3>
<ul>
<li>变换之后</li>
</ul>
<ol>
<li>直线依旧是直线</li>
<li>原点位置保持不变</li>
<li>网格线保持变形且等距分布</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281915176.png" alt="image-20220828191508017" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281915031.png" alt="image-20220828191523924" /></p>
<h3 id="向量依赖于基向量的数乘和相加"><a class="anchor" href="#向量依赖于基向量的数乘和相加">#</a> 向量依赖于基向量的数乘和相加</h3>
<p>变换前的基向量：i 帽 (1,0) T 和 j 帽 (0,1) T<br />
 因从：只需要记录基向量 i 帽和 j 帽变换后的位置 ——&gt; 就能推断出任意向量变换之后的位置</p>
<ul>
<li>
<p>变换前：基向量与向量的关系</p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281925352.png" alt="image-20220828192525266" /></p>
</li>
<li>
<p>变换后：基向量与向量的关系</p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208281928652.png" alt="image-20220828192812533" /></p>
</li>
</ul>
<p>变换前：i 帽 (1,0) T，j 帽 (0,1) T，基于 i 帽和 j 帽的任意向量 (x，y) T</p>
<p>x 和 y 分别为基向量数乘的标量，标量 x 和 y 乘以基向量后相加 ——&gt;(x,y) T</p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208282003851.png" alt="image-20220828200306782" /></li>
</ul>
<h3 id="矩阵就是对空间的一种特定变换"><a class="anchor" href="#矩阵就是对空间的一种特定变换">#</a> 矩阵就是对空间的一种特定变换</h3>
<ul>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208282033065.png" alt="image-20220828203356019" /></p>
</li>
<li>
<p>所以二维线性变换仅由四个数字完全确定：</p>
<ul>
<li>
<p><strong>变换后</strong> i 帽的两个坐标 和 j 帽的两个坐标</p>
</li>
<li>
<p>将 i 帽和 j 帽封装一起 ——&gt; 得到了<strong>描述线性变化的矩阵</strong></p>
<ul>
<li>矩阵的列就是变换后的基向量</li>
</ul>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208282010335.png" alt="image-20220828201059237" /></p>
</li>
<li>
<p>描述线性变换的矩阵 * 输入向量 (变换前) = 输出向量 (变换后)</p>
<ul>
<li>这就是缩放基向量再相加的思想</li>
</ul>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208282014521.png" alt="image-20220828201438460" /></p>
</li>
<li>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208282018001.png" alt="image-20220828201822914" /></p>
</li>
</ul>
</li>
</ul>
<p>实质上矩阵的向量乘法就是基向量的线性组合</p>
<ul>
<li><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208282020772.png" alt="image-20220828202059638" /></li>
</ul>
<p>矩阵 ——&gt; 对空间的一种特定变换</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208282057071.png" alt="image-20220828205743944" /></p>
<h2 id="矩阵乘法与线性变换复合"><a class="anchor" href="#矩阵乘法与线性变换复合">#</a> 矩阵乘法与线性变换复合</h2>
<p>矩阵代表一个特定的线性变换</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208282245530.png" alt="image-20220828224522885" /></p>
<p>矩阵与向量相乘就是将矩阵所表示的线性变换作用于那个向量</p>
<ul>
<li><strong>矩阵在左边：看作对变量做变换的一个函数</strong></li>
<li><strong>被变换的向量在右边：看作一个被变换的变量</strong><br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208290006984.png" alt="image-20220829000639814" /></li>
</ul>
<p>线性变化的复合变换</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208290054884.png" alt="image-20220829005412680" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208290055645.png" alt="image-20220829005556548" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208290102823.png" alt="image-20220829010206744" /></p>
<p>矩阵与矩阵的相乘<br />
让 (左) 矩阵所代表的线性变换分别作用于 (右) 矩阵的的每一列向量，分别得到两列变换后的向量，最后复合成一个矩阵</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208290128164.png" alt="image-20220829012851080" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208290129323.png" alt="image-20220829012949235" /></p>
<p>找到 (右) 矩阵中已经变换过的 i 帽，将 (左) 矩阵所代表的线性变换作用于 i 帽 ——&gt; 得到复合矩阵的第一列</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291026658.png" alt="image-20220829102627467" /></p>
<p>找到 (右) 矩阵中已经变换过的 j 帽，将 (左) 矩阵所代表的线性变换作用于 j 帽 ——&gt; 得到复合矩阵的第二列</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291028563.png" alt="image-20220829102812456" /></p>
<p>矩阵不满足交换律</p>
<ul>
<li>变换的顺序 (右 ——&gt; 左) 发生改变 ——&gt; 对结果产生影响</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291031262.png" alt="image-20220829103129203" /></p>
<p>先剪切后旋转</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291036279.png" alt="image-20220829103634148" /></p>
<p>先旋转后剪切</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291037580.png" alt="image-20220829103708402" /></p>
<p>矩阵满足结合律</p>
<ul>
<li>变换的顺序 (右 ——&gt; 左) 保持不变 ——&gt; 对结果没有影响</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291041455.png" alt="image-20220829104112332" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291041904.png" alt="image-20220829104128776" /></p>
<h3 id="二维空间的线性变换"><a class="anchor" href="#二维空间的线性变换">#</a> 二维空间的线性变换</h3>
<p>所有向量依赖于两个基向量：x 轴上的 i 帽和 y 轴上的 j 帽<br />
原始的 i 帽：(1,0)<br />
 原始的 j 帽：(0,1)<br />
<strong> i 帽作用于向量的 x 坐标</strong><br />
<strong> j 帽作用于向量的 y 坐标</strong><br />
二维矩阵相乘：是对二维基向量连续做了两次变换，右边矩阵是对原始的基向量变换后的矩阵。</p>
<ul>
<li>矩阵对向量做变换：x 坐标对 i 帽进行放缩，y 坐标对 j 帽进行放缩</li>
</ul>
<ol>
<li>将右边矩阵的每一列向量分立出来，得到二列向量</li>
<li>再让左边矩阵分别作用（放缩再相加）于每一个向量，得到二列变换后的向量</li>
<li>再将二列变换后的向量放在一个 2 * 2 的矩阵中得到了最终变换的结果<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291051328.png" alt="image-20220829105100186" /></li>
</ol>
<h3 id="三维空间的线性变换"><a class="anchor" href="#三维空间的线性变换">#</a> 三维空间的线性变换</h3>
<p>所有向量依赖于三个基向量：x 轴的 i 帽，y 轴的 j 帽和 z 轴的 k 帽<br />
原始的 i 帽：(1,0,0)<br />
 原始的 j 帽：(0,1,0)<br />
 原始的 k 帽：(0,0,1)<br />
<strong> i 帽作用于向量的 x 坐标</strong><br />
<strong> j 帽作用于向量的 y 坐标</strong><br />
<strong> k 帽作用于向量的 z 坐标</strong><br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291052161.png" alt="image-20220829105208060" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291146990.png" alt="image-20220829114654704" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291148701.png" alt="image-20220829114801620" /></p>
<p>将三个基向量记录在一个 3 * 3 的矩阵中</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291201114.png" alt="image-20220829120134015" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291201269.png" alt="image-20220829120151165" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291205509.png" alt="image-20220829120543384" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291204770.png" alt="image-20220829120403648" /></p>
<p>三维矩阵相乘：是对三维基向量连续做了两次变换，右边矩阵是对原始的基向量变换后的矩阵。</p>
<ul>
<li>矩阵对向量做变换：x 坐标对 i 帽进行放缩，y 坐标对 j 帽进行放缩，z 坐标对 k 帽进行放缩</li>
</ul>
<ol>
<li>将右边矩阵的每一列向量分立出来，得到三列向量</li>
<li>再让左边矩阵分别作用（放缩再相加）于每一个向量，得到三列变换后的向量</li>
<li>再将三列变换后的向量放在一个 3 * 3 的矩阵中得到了最终变换的结果<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291208573.png" alt="image-20220829120839353" /></li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291211882.png" alt="image-20220829121135808" /></p>
<h2 id="行列式"><a class="anchor" href="#行列式">#</a> 行列式</h2>
<h3 id="二维空间中的行列式"><a class="anchor" href="#二维空间中的行列式">#</a> 二维空间中的行列式</h3>
<p>在二维空间中，基向量 i 帽 (1,0) 和 j 帽 (0,1) 可构成一个底为 1，高为 1 的正方形，面积为 1&lt;——&gt; 由基向量狗构成的原始的矩阵的行列式值为 1<br />
 将基向量变换后得到的矩阵的行列式值 ——&gt; 变换后基向量所构成四边形的面积（放缩的倍数）</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291519736.png" alt="image-20220829151907634" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291518138.png" alt="image-20220829151808015" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291517516.png" alt="image-20220829151751415" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291520328.png" alt="image-20220829152040228" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291521854.png" alt="image-20220829152111720" /><br />
 将空间压缩到了一条直线上<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291523203.png" alt="image-20220829152322085" /><br />
 将空间压缩到了更小的维度上<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291524164.png" alt="image-20220829152431072" /></p>
<p>行列式的负值<br />
如果矩阵的行列式为负值，则说明矩阵所表示的变换使空间的定向发生了改变（想象将一张纸表示的二维平面翻转过来）<br />
行列式的绝对值依然表示区域面积的缩放比例<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291526010.png" alt="image-20220829152609927" /><br />
 定向改变前</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291529088.png" alt="image-20220829152940009" /><br />
 定向改变后</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291530412.png" alt="image-20220829153014235" /></p>
<p>假设变换后的 i 帽从一个方向不断靠近 j 帽，并转换到 j 帽的另一个方向</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291533237.png" alt="image-20220829153342080" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291534564.png" alt="image-20220829153411486" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291534881.png" alt="image-20220829153438729" /></p>
<h3 id="三维空间中的行列式"><a class="anchor" href="#三维空间中的行列式">#</a> 三维空间中的行列式</h3>
<p>在三维空间中则将对象聚焦到一个 i 帽，j 帽，k 帽所表示的 1 * 1* 1 的立方体中，矩阵的行列式值表示矩阵的空间中区域体积的放缩比例<br />
立方体初始体积为 1<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291539913.png" alt="image-20220829153932808" /></p>
<p>正方体被压缩为了平行六面体<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291541352.png" alt="image-20220829154101167" /></p>
<p>原始立方体体积为 1，变换后的比例则为变换后立方体的体积<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291543546.png" alt="image-20220829154317442" /></p>
<p>三维空间行列式正负所表示的定向</p>
<p>右手定则（行列式为正）</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291556824.png" alt="image-20220829155614722" /></p>
<p>左手定则（行列式为负）</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291557353.png" alt="image-20220829155705237" /></p>
<p>矩阵行列式值的计算</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291558766.png" alt="image-20220829155858714" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291601077.png" alt="image-20220829160120994" /></p>
<h2 id="逆矩阵-列空间和零空间"><a class="anchor" href="#逆矩阵-列空间和零空间">#</a> 逆矩阵、列空间和零空间</h2>
<h3 id="线性方程组"><a class="anchor" href="#线性方程组">#</a> 线性方程组</h3>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291610794.png" alt="image-20220829161018718" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291611647.png" alt="image-20220829161120545" /></p>
<ul>
<li>矩阵 A 代表一种线性变换</li>
<li>A<strong>x</strong> = <strong>v</strong> 意味着找到一个<strong> x</strong> 向量经过矩阵<strong> A</strong> 变换后可以和向量<strong> v</strong> 重合</li>
</ul>
<h3 id="逆矩阵"><a class="anchor" href="#逆矩阵">#</a> 逆矩阵</h3>
<p>向量经过矩阵 (A) 变换后，再经过 A 的逆矩阵 (A 逆) 变换，则会回到原来的状态</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291648645.png" alt="image-20220829164858537" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291648725.png" alt="image-20220829164838622" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291704377.png" alt="image-20220829164941847" /></p>
<p>矩阵的行列式不为 0，则矩阵存在逆矩阵</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291651600.png" alt="image-20220829165133543" /></p>
<p>求解 Ax = v，只需要将 v 乘以 A 的逆矩阵 ——&gt;x</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291653530.png" alt="image-20220829165302361" /></p>
<h3 id="矩阵的秩"><a class="anchor" href="#矩阵的秩">#</a> 矩阵的秩</h3>
<p>矩阵的秩表示<strong>变换后</strong>的空间的维数<br />
秩如果小于原来空间的维数 ——&gt; 原空间被压缩了<br />
<img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291656465.png" alt="image-20220829165647388" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291657563.png" alt="image-20220829165703449" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291657829.png" alt="image-20220829165725685" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291657397.png" alt="image-20220829165752082" /></p>
<h3 id="列空间"><a class="anchor" href="#列空间">#</a> 列空间</h3>
<p>矩阵的列所张成的空间</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291708743.png" alt="image-20220829170833638" /></p>
<p>秩与矩阵的列数相等 ——&gt; 满秩</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291709927.png" alt="image-20220829170955802" /></p>
<p>线性变化必须保持原点位置不变 ——&gt; 零向量一定在列空间中</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291711990.png" alt="image-20220829171110879" /></p>
<h3 id="零空间"><a class="anchor" href="#零空间">#</a> 零空间</h3>
<p><strong>变换后落在原点的向量的集合 —— 矩阵的零空间或矩阵的核</strong></p>
<h2 id="非方阵"><a class="anchor" href="#非方阵">#</a> 非方阵</h2>
<p><strong>可笑的是，有人尝试去求非方阵的行列式</strong></p>
<p>不同维数之间的变换是合理的</p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291720662.png" alt="image-20220829172025578" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291720104.png" alt="image-20220829172040022" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208291721417.png" alt="image-20220829172107226" /></p>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类算法</title>
    <url>/2022/08/29/ju-lei-suan-fa/</url>
    <content><![CDATA[<h1 id="聚类算法"><a class="anchor" href="#聚类算法">#</a> 聚类算法</h1>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312140084.png" alt="image-20220831214052038" /></p>
<h2 id="k-means"><a class="anchor" href="#k-means">#</a> K－MEANS</h2>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312141041.png" alt="image-20220831214059985" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312141450.png" alt="image-20220831214106407" /></p>
<ol>
<li>刚开始根据 K 值随机初始化了 K 个质心，根据质心来划分，所有点离某一个质心的距离最小，就属于那个质心一类。</li>
<li>分完类后，根据已经划分好的所有点中，计算更新每一个类别（簇）的质心， 重新根据每一个点到质心的距离来划分。</li>
<li>就这样不断的更新每一个类别的质心，不断重新遍历所有的点，根据质心重新划分类别。</li>
<li>直到所有点的类别都不再发生改变，更新和划分就结束了。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312141670.png" alt="image-20220831214116626" /></p>
<ul>
<li>初始值对最终结果影响大，多数情况都可以分好</li>
</ul>
<h2 id="dbscan"><a class="anchor" href="#dbscan">#</a> DBSCAN</h2>
<ul>
<li>基于密度 (传销) 的一种方法</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312141002.png" alt="image-20220831214134958" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312141166.png" alt="image-20220831214140126" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312141944.png" alt="image-20220831214147894" /></p>
<ul>
<li>在同一个簇中，不是核心点，就是边界对象</li>
<li>不在任何一个簇中的点是离群点</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312142585.png" alt="image-20220831214221546" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312142585.png" alt="" /></p>
<p>对所有的点进行扫描，在数据集中每次找一个点，以这个点为圆心，画一个指定半径 (eps) 的圆，在这个圆内的其他点就是与这个点密切的点，如果些点的数量达到一定的数量 (min_samples)，也就是达到阈值，就可以认为这个点是核心点。</p>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>贝叶斯算法</title>
    <url>/2022/08/29/bei-xie-si-suan-fa/</url>
    <content><![CDATA[<h1 id="贝叶斯算法"><a class="anchor" href="#贝叶斯算法">#</a> 贝叶斯算法</h1>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312135687.png" alt="image-20220831213551651" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312135501.png" alt="image-20220831213557441" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312137978.png" alt="image-20220831213744914" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312136838.png" alt="image-20220831213617793" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312136906.png" alt="image-20220831213625862" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312136926.png" alt="image-20220831213630889" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312136457.png" alt="image-20220831213636413" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312137183.png" alt="image-20220831213711096" /></p>
<p><img data-src="https://raw.githubusercontent.com/YN-XS/images/master/study_imgs/202208312137078.png" alt="image-20220831213717015" /></p>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
